<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head> <meta name = "Author" content = "EconARK.org">  
<meta name = "Description" content = """>  
<"A Users Guide for HARK: Heterogeneous Agents Resources and toolKit"></"A Users Guide for HARK: Heterogeneous Agents Resources and toolKit">  
 <title>A User&#8217;s Guide for HARK:
Heterogeneous Agents Resources and toolKit</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.tug.org/tex4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.tug.org/tex4ht/)"> 
<!-- html,pic-tabular,pic-m,pic-array,pic-eqnarray,info --> 
<meta name="src" content="HARKmanual.tex"> 
<link rel="stylesheet" type="text/css" href="HARKmanual.css"> 
</head><body 
>
<!--l. 438--><p class="indent" >  <span class="footnote-mark"><sup class="textsuperscript"></sup></span>
  <div class="maketitle">
<h2 class="titleHead">A User&#8217;s Guide for HARK:<br />
Heterogeneous Agents Resources and toolKit</h2>
<div class="date" > August 30, 2017</div>
<span 
class="ecrm-0600">&#x00A0;</span>
                  <div class="author" >  <span 
class="ecrm-1440">Christopher D Carroll</span><sup class="textsuperscript"><span 
class="ecrm-0600">1</span></sup>
<br />      <span 
class="ecrm-1095">Johns Hopkins University </span><br class="and" /><span 
class="ecrm-1440">Alexander M Kaufman</span><sup class="textsuperscript"><span 
class="ecrm-0600">2</span></sup>
<br />      <span 
class="ecrm-1095">Consumer Financial Protection Bureau </span><br class="and" /><span 
class="ecrm-1440">David C Low</span><sup class="textsuperscript"><span 
class="ecrm-0600">3</span></sup>
<br />   <span 
class="ecrm-1095">Consumer Financial Protection Bureau </span><br class="and" /><span 
class="ecrm-1440">Nathan M Palmer</span><sup class="textsuperscript"><span 
class="ecrm-0600">4</span></sup>
<br /> <span 
class="ecrm-1095">U.S.</span><span 
class="ecrm-1095">&#x00A0;Treasury Office of Financial Research </span><br class="and" /><span 
class="ecrm-1440">Matthew N White</span><sup class="textsuperscript"><span 
class="ecrm-0600">5</span></sup>
<br />                     <span 
class="ecrm-1095">University of Delaware </span></div><br />
</div>
<div class="center" 
>
<!--l. 438--><p class="noindent" >
<!--l. 438--><p class="noindent" ><img 
src="HARKmanual0x.png" alt="PIC" class="graphics"><!--tex4ht:graphics  
name="HARKmanual0x.png" src="UserGuidePic.pdf"  
--></div>
<!--l. 438--><p class="indent" >
      <sup class="textsuperscript"></sup>
<!--l. 438--><p class="noindent" ><sup class="textsuperscript"><span 
class="ecrm-0600">1</span></sup> <span 
class="ecrm-1000">Carroll: </span><a 
href="http://econ.jhu.edu/people/ccarroll/" class="url" ><span 
class="ectt-1000">http://econ.jhu.edu/people/ccarroll/</span></a><span 
class="ecrm-1000">, email: </span><a 
href="mailto:ccarroll@jhu.edu" ><span 
class="ectt-1000">ccarroll@jhu.edu</span></a> <span 
class="ecrm-1000">&#x00A0;</span><span 
class="ecrm-1000">&#x00A0;</span><span 
class="ecrm-1000">&#x00A0;</span><span 
class="ecrm-1000">&#x00A0; </span><sup class="textsuperscript"><span 
class="ecrm-0600">2</span></sup>
<span 
class="ecrm-1000">Kaufman: </span><a 
href="mailto:alexander.kaufman@cfpb.gov" ><span 
class="ectt-1000">alexander.kaufman@cfpb.gov</span></a> <span 
class="ecrm-1000">&#x00A0;</span><span 
class="ecrm-1000">&#x00A0;</span><span 
class="ecrm-1000">&#x00A0;</span><span 
class="ecrm-1000">&#x00A0; </span><sup class="textsuperscript"><span 
class="ecrm-0600">3</span></sup> <span 
class="ecrm-1000">Low: </span><a 
href="mailto:david.c.low@cfpb.gov" ><span 
class="ectt-1000">david.c.low@cfpb.gov</span></a> <span 
class="ecrm-1000">&#x00A0;</span><span 
class="ecrm-1000">&#x00A0;</span><span 
class="ecrm-1000">&#x00A0;</span><span 
class="ecrm-1000">&#x00A0; </span><sup class="textsuperscript"><span 
class="ecrm-0600">4</span></sup> <span 
class="ecrm-1000">Palmer:</span>
<a 
href="mailto:nathan.m.palmer@ofr.treasury.gov" ><span 
class="ectt-1000">nathan.m.palmer@ofr.treasury.gov</span></a> <span 
class="ecrm-1000">&#x00A0;</span><span 
class="ecrm-1000">&#x00A0;</span><span 
class="ecrm-1000">&#x00A0;</span><span 
class="ecrm-1000">&#x00A0; </span><sup class="textsuperscript"><span 
class="ecrm-0600">5</span></sup> <span 
class="ecrm-1000">White: </span><a 
href="mailto:mnwecon@udel.edu" ><span 
class="ectt-1000">mnwecon@udel.edu</span></a> <span 
class="ecrm-1000">&#x00A0;</span><span 
class="ecrm-1000">&#x00A0;</span><span 
class="ecrm-1000">&#x00A0;</span><span 
class="ecrm-1000">&#x00A0;</span>
                                                                                        
                                                                                        
  <h3 class="likesectionHead"><a 
 id="x1-1000"></a>Contents</h3>
  <div class="tableofcontents">
  <span class="sectionToc" >1 <a 
href="#x1-20001" id="QQ2-1-2">Introduction</a></span>
<br />  &#x00A0;<span class="subsectionToc" >1.1 <a 
href="#x1-30001.1" id="QQ2-1-3">Getting Started</a></span>
<br />  &#x00A0;<span class="subsectionToc" >1.2 <a 
href="#x1-40001.2" id="QQ2-1-4">Structure of HARK</a></span>
<br />  &#x00A0;<span class="subsectionToc" >1.3 <a 
href="#x1-50001.3" id="QQ2-1-5">Other Resources</a></span>
<br />  <span class="sectionToc" >2 <a 
href="#x1-60002" id="QQ2-1-6">General Purpose Tools</a></span>
<br />  &#x00A0;<span class="subsectionToc" >2.1 <a 
href="#x1-70002.1" id="QQ2-1-7">HARKcore</a></span>
<br />  &#x00A0;<span class="subsectionToc" >2.2 <a 
href="#x1-80002.2" id="QQ2-1-8">HARKutilities</a></span>
<br />  &#x00A0;<span class="subsectionToc" >2.3 <a 
href="#x1-90002.3" id="QQ2-1-9">HARKinterpolation</a></span>
<br />  &#x00A0;<span class="subsectionToc" >2.4 <a 
href="#x1-100002.4" id="QQ2-1-10">HARKsimulation</a></span>
<br />  &#x00A0;<span class="subsectionToc" >2.5 <a 
href="#x1-110002.5" id="QQ2-1-11">HARKestimation</a></span>
<br />  &#x00A0;<span class="subsectionToc" >2.6 <a 
href="#x1-120002.6" id="QQ2-1-12">HARKparallel</a></span>
<br />  <span class="sectionToc" >3 <a 
href="#x1-130003" id="QQ2-1-13">Microeconomics: the AgentType Class</a></span>
<br />  &#x00A0;<span class="subsectionToc" >3.1 <a 
href="#x1-140003.1" id="QQ2-1-14">Attributes of an AgentType</a></span>
<br />  &#x00A0;<span class="subsectionToc" >3.2 <a 
href="#x1-150003.2" id="QQ2-1-15">A Universal Solver</a></span>
<br />  &#x00A0;<span class="subsectionToc" >3.3 <a 
href="#x1-160003.3" id="QQ2-1-16">The Flow of Time and Other Methods</a></span>
<br />  &#x00A0;<span class="subsectionToc" >3.4 <a 
href="#x1-170003.4" id="QQ2-1-17">Sample Model: Perfect Foresight Consumption-Saving</a></span>
<br />  <span class="sectionToc" >4 <a 
href="#x1-180004" id="QQ2-1-18">Macroeconomics: the Market Class</a></span>
<br />  &#x00A0;<span class="subsectionToc" >4.1 <a 
href="#x1-190004.1" id="QQ2-1-19">Down on the Farm</a></span>
<br />  &#x00A0;<span class="subsectionToc" >4.2 <a 
href="#x1-200004.2" id="QQ2-1-20">Attributes of a Market</a></span>
<br />  &#x00A0;<span class="subsectionToc" >4.3 <a 
href="#x1-210004.3" id="QQ2-1-21">Sample Model: FashionVictim</a></span>
<br />  <span class="sectionToc" >5 <a 
href="#x1-220005" id="QQ2-1-22">Contributing to HARK</a></span>
<br />  &#x00A0;<span class="subsectionToc" >5.1 <a 
href="#x1-230005.1" id="QQ2-1-23">What Does HARK Want?</a></span>
<br />  &#x00A0;<span class="subsectionToc" >5.2 <a 
href="#x1-240005.2" id="QQ2-1-24">Git and GitHub</a></span>
<br />  &#x00A0;<span class="subsectionToc" >5.3 <a 
href="#x1-250005.3" id="QQ2-1-25">Submission Approval Process</a></span>
<br />  &#x00A0;<span class="subsectionToc" >5.4 <a 
href="#x1-260005.4" id="QQ2-1-26">Naming Conventions</a></span>
<br />  &#x00A0;<span class="subsectionToc" >5.5 <a 
href="#x1-270005.5" id="QQ2-1-27">Documentation Conventions</a></span>
<br />  <span class="sectionToc" >6 <a 
href="#x1-280006" id="QQ2-1-28">Future of HARK</a></span>
<br />  &#x00A0;<span class="subsectionToc" >6.1 <a 
href="#x1-290006.1" id="QQ2-1-29">Future Tools</a></span>
<br />  &#x00A0;<span class="subsectionToc" >6.2 <a 
href="#x1-300006.2" id="QQ2-1-30">Future Models</a></span>
<br />  &#x00A0;<span class="subsectionToc" >6.3 <a 
href="#x1-310006.3" id="QQ2-1-31">Bounty Hunting</a></span>
<br />  &#x00A0;<span class="subsectionToc" >6.4 <a 
href="#x1-320006.4" id="QQ2-1-32">All Aboard the Ark</a></span>
  </div>
<!--l. 438--><p class="indent" >
                                                                                        
                                                                                        
  <h3 class="sectionHead"><span class="titlemark">1  </span> <a 
 id="x1-20001"></a>Introduction</h3>
<!--l. 438--><p class="noindent" >If you are willing to risk some mild psychological trauma, conjure to mind your first experience of
hand-coding a structural economic model. Your clunky effort probably built on legacy code
provided by an adviser or colleague &#8211; which itself came from who-knows-what apocryphal
sources. Efforts to combine elements from one model with those from another were likely
frustrated by the &#8220;Tower of Babel&#8221; problem: Code from one source could not &#8220;speak&#8221; to code
from another without your own intermediation as a translator, possibly between two unfamiliar
languages and aided only by oracular comments that, at best, made sense only in the context of
other (now missing) code.
<!--l. 438--><p class="indent" >  After months of effort, you may have had the character-improving experience of proudly
explaining to your adviser that not only had you grafted two ideas together, you also found a
trick that speeded the solution by an order of magnitude, only to be told that your breathtaking
insight had been understood for many years, as reflected in an appendix to a 2008 paper; or,
worse, your discovery was something that &#8220;everybody knows&#8221; but did not exist at all in published
form!
<!--l. 438--><p class="indent" >  Learning by doing has value, but only within limits. We do not require young drivers to design
an internal combustion engine before driving a car, nor must graduate students write their own
matrix inversion algorithms before running an OLS regression.
<!--l. 438--><p class="indent" >  In recent years, considerable progress has been made in addressing these kinds of problems in
many areas of economic modeling. Macroeconomists using representative agent models can send
Dynare model files to each other; reduced form econometricians can choose from a host of
econometric packages. But modelers whose questions require explicit structural modeling
involving nontrivial kinds of heterogeneity (that is, heterogeneity that cannot simply be
aggregated away) are mostly still stuck in the bad old days.
<!--l. 438--><p class="indent" >  The ultimate goal of the HARK project is to fix these problems. Specifically, our aim is to
produce an open source repository of highly modular, easily interoperable code for
solving, simulating, and estimating dynamic economic models with heterogeneous
agents.<span class="footnote-mark"><a 
href="HARKmanual2.html#fn2x0"><sup class="textsuperscript">2</sup></a></span><a 
 id="x1-2001f2"></a> 
Further, we seek to establish (with input from the community) standards for the description and
specification of objects like discrete approximations to continuous distributions and interpolated
function approximations, so that numeric methods can be quickly swapped without ugly
&#8220;patching.&#8221;
<!--l. 438--><p class="indent" >  We hope that HARK will make it much easier and faster for researchers to develop solution
and estimation methods for new models. The open source nature of HARK will make
it easier for other researchers to audit and verify new models and methods, and to
collaborate on correcting deficiencies when found. As HARK expands to include more
                                                                                        
                                                                                        
canonical models and more tools and utilities, we can all spend less time managing
numerical minutiae and more time fretting about identification arguments and data
accuracy.
  <h4 class="subsectionHead"><span class="titlemark">1.1  </span> <a 
 id="x1-30001.1"></a>Getting Started</h4>
<!--l. 438--><p class="noindent" >If you want to get started using HARK right away, this section provides a very easy quickstart
guide for getting HARK up and running on your computer in just a few minutes. More
information can be found in the <span 
class="ectt-1200">README.md </span>file in the HARK repository (step 4), but here is a
quick version for those who want to jump right in:
<!--l. 438--><p class="indent" >
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x1-3002x1"><span 
class="ecbx-1200">Download Anaconda: </span>Go to <a 
href="https://www.continuum.io/downloads" >https://www.continuum.io/downloads</a> and download
      Anaconda for your operating system; be sure to get the version for Python 2.7.
      </li>
      <li 
  class="enumerate" id="x1-3004x2"><span 
class="ecbx-1200">Install Anaconda: </span>Follow the easy instructions on that page to install Anaconda.
      </li>
      <li 
  class="enumerate" id="x1-3006x3"><span 
class="ecbx-1200">Add extra packages: </span>(optional) If you want to use HARK&#8217;s multithreading feature,
      you need to add two packages that aren&#8217;t part of the default Anaconda distribution.
      Simply open a command prompt and do <span 
class="ectt-1200">conda install joblib </span>and <span 
class="ectt-1200">conda install</span>
      <span 
class="ectt-1200">dill</span>, accepting defaults to install.
      </li>
      <li 
  class="enumerate" id="x1-3008x4"><span 
class="ecbx-1200">Download   HARK:  </span>Go   to   <a 
href="https://github.com/econ-ark/HARK" >https://github.com/econ-ark/HARK</a>,   the   home
      of  the  HARK  repository.  Click  on  the  lime  green  button  labeled  &#8220;Clone  or
      download&#8221;  toward  the  upper  right  of  the  main  panel,  and  select  &#8220;Download
      ZIP&#8221;.<span class="footnote-mark"><a 
href="HARKmanual3.html#fn3x0"><sup class="textsuperscript">3</sup></a></span><a 
 id="x1-3009f3"></a> 
      </li>
      <li 
  class="enumerate" id="x1-3011x5"><span 
class="ecbx-1200">Unzip HARK: </span>Unpack the <span 
class="ectt-1200">HARK.zip </span>file using any archive utility, like <a 
href="http://www.peazip.org/" >Peazip</a>. Put
      the files anywhere you&#8217;d like, maintaining the internal directory structure.
      </li>
      <li 
  class="enumerate" id="x1-3013x6"><span 
class="ecbx-1200">Run Spyder: </span>Open a command prompt and do <span 
class="ectt-1200">spyder</span>. Spyder is an interactive
      development environment (IDE) for iPython, a slightly prettier, more interactive
      flavor of Python.
                                                                                        
                                                                                        
      </li>
      <li 
  class="enumerate" id="x1-3015x7"><span 
class="ecbx-1200">Open a HARK module: </span>Go to the directory where you put HARK and open any
      file          with          the          <span 
class="ectt-1200">.py      </span>extension;          we          recommend
      <span 
class="ectt-1200">/ConsumptionSaving/ConsIndShockModel.py</span>.
      </li>
      <li 
  class="enumerate" id="x1-3017x8"><span 
class="ecbx-1200">Run the module: </span>Click on the green arrow &#8220;play&#8221; button toward the right side of
      the toolbar of icons at the top of the Spyder window (accept defaults if a dialogue
      box pops up). Congratulations! HARK is now up and running on your computer.</li></ol>
<!--l. 438--><p class="indent" >  If you followed our recommendation to try <span 
class="ectt-1200">/ConsumptionSaving/ConsIndShockModel.py</span>,
you should see graphical representations of the solution to a few consumption-saving
models with idiosyncratic shocks to permanent and transitory income (see
<span 
class="ectt-1200">/Documentation/ConsumptionSavingModels.pdf </span>for details of these models). If you chose a
different module, you might get some examples of some other model, results of a structural
estimation, a polite notification that this particular module doesn&#8217;t do much on its own, or no
output at all. See the <span 
class="ectt-1200">README.md </span>for a full list of modules from which you can expect non-trivial
output.
<!--l. 438--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">1.2  </span> <a 
 id="x1-40001.2"></a>Structure of HARK</h4>
<!--l. 438--><p class="noindent" >HARK is written in Python, an object-oriented programming (OOP) language that has
experienced increasing popularity in the scientific community in the past several years. A
significant reason for the adoption of Python is the <span 
class="ectt-1200">numpy </span>and <span 
class="ectt-1200">scipy </span>packages, which offer a
wide array of mathematical and statistical functions and tools; HARK makes liberal
use of these libraries. Python&#8217;s object-oriented nature allows models in HARK to
be easily extended: more complex models can inherit functions and methods from
more fundamental &#8220;parent&#8221; models, eliminating the need to reproduce or repurpose
code.
<!--l. 438--><p class="indent" >  As implied in the previous section, we strongly encourage HARK users to use the Anaconda
distribution of Python, which includes all commonly used mathematical and scientific packages,
an interactive development environment for iPython (Spyder), and a package manager that
allows users to quickly install or update packages not included in the default distribution
(conda).
<!--l. 438--><p class="indent" >  For users unfamiliar with OOP, we strongly encourage you to review the background material
on OOP provided by the good people at <a 
href="http://quant-econ.net/" >QuantEcon</a> (for more on them, see below) at this link:
<a 
href="http://quant-econ.net/py/python_oop.html" >Object Oriented Programming</a>. Unlike non-OOP languages, OOP bundles together
data and functions into <span 
class="ecti-1200">objects</span>. These can be accessed via: <span 
class="ectt-1200">object_name.data </span>and
<span 
class="ectt-1200">object_name.method_name()</span>, respectively. For organizational purposes, definitions of multiple
objects are stored in <span 
class="ecti-1200">modules</span>, which are simply files with a <span 
class="ectt-1200">.py </span>extension. Modules can be
                                                                                        
                                                                                        
accessed in Python via:<br 
class="newline" />
<!--l. 438--><p class="indent" >  <span 
class="ectt-1200">import module_name as import_name </span><br 
class="newline" />
<!--l. 438--><p class="noindent" >This imports the module and gives it a local name of <span 
class="ectt-1200">import_name</span>. We can access a function
within this module by simply typing: <span 
class="ectt-1200">import_name.function_name()</span>. The following example
will illustrate the usage of these commands. <span 
class="ectt-1200">CRRAutility </span>is the function object for calculating
CRRA utility supplied by <span 
class="ectt-1200">HARKutilities </span>module. <span 
class="ectt-1200">CRRAutility </span>is called <span 
class="ecti-1200">attributes </span>of the
module <span 
class="ectt-1200">HARKutilities</span>. In order to calculate CRRA utility with a consumption of 1 and a
coefficient of risk aversion of 2 we run:<br 
class="newline" />
<!--l. 438--><p class="indent" >  <span 
class="ectt-1200">import HARKutilities as Hutil</span>
<!--l. 438--><p class="indent" >  <span 
class="ectt-1200">Hutil.CRRAutility(1,2)</span><br 
class="newline" />
<!--l. 438--><p class="indent" >  Python modules in HARK can generally be categorized into three types: tools, models, and
applications. <span 
class="ecbx-1200">Tool modules </span>contain functions and classes with general purpose tools that have
no inherent &#8220;economic content&#8221;, but that can be used in many economic models as building
blocks or utilities; they could plausibly be useful in non-economic settings. Tools might include
functions for data analysis (e.g.&#x00A0;calculating Lorenz shares from data, or constructing a
non-parametric kernel regression), functions to create and manipulate discrete approximations to
continuous distributions, or classes for constructing interpolated approximations to
non-parametric functions. Tool modules generally reside in HARK&#8217;s root directory and have
names like <span 
class="ectt-1200">HARKsimulation </span>and <span 
class="ectt-1200">HARKinterpolation</span>; they do not necessarily do anything when
run.
<!--l. 438--><p class="indent" >  <span 
class="ecbx-1200">Model modules </span>specify particular economic models, including classes to represent agents in
the model (and the &#8220;market structure&#8221; in which they interact) and functions for solving the
&#8220;one period problem&#8221; of those models. For example, <span 
class="ectt-1200">ConsIndShockModel.py </span>concerns
consumption-saving models in which agents have CRRA utility over consumption and face
idiosyncratic shocks to permanent and transitory income. The module includes classes for
representing &#8220;types&#8221; of consumers, along with functions for solving (several flavors of) the one
period consumption-saving problem. When run, model modules might demonstrate example
specifications of their models, filling in the model parameters with arbitrary values. When
<span 
class="ectt-1200">ConsIndShockModel.py </span>is run, it specifies an infinite horizon consumer with a particular
discount factor, permanent income growth rate, coefficient of relative risk aversion (etc), who
faces lognormal shocks to permanent and transitory income each period with a particular
standard deviation; it then solves this consumer&#8217;s problem and graphically displays the
results.<span class="footnote-mark"><a 
href="HARKmanual4.html#fn4x0"><sup class="textsuperscript">4</sup></a></span><a 
 id="x1-4001f4"></a> 
Model modules generally have <span 
class="ectt-1200">Model </span>in their name.
                                                                                        
                                                                                        
<!--l. 438--><p class="indent" >  <span 
class="ecbx-1200">Application modules </span>use tool and model modules to solve, simulate, and/or estimate
economic models <span 
class="ecti-1200">for a particular purpose</span>. While tool modules have no particular economic
content and model modules describe entire classes of economic models, applications are uses of a
model for some research purpose. For example, <span 
class="ectt-1200">/SolvingMicroDSOPs/StructEstimation.py</span>
uses a consumption-saving model from <span 
class="ectt-1200">ConsIndShockModel.py</span>, calibrating it with
age-dependent sequences of permanent income growth, survival probabilities, and the standard
deviation of income shocks (etc); it then estimates the coefficient of relative risk aversion and
shifter for an age-varying sequence of discount factors that best fits simulated wealth profiles
to empirical data from the Survey of Consumer Finance. A particular application
might have multiple modules associated with it, all of which generally reside in one
directory.
  <h4 class="subsectionHead"><span class="titlemark">1.3  </span> <a 
 id="x1-50001.3"></a>Other Resources</h4>
<!--l. 438--><p class="noindent" >In the incredibly unlikely scenario in which this document does not fill all of the gaps in your
knowledge and answer any questions you might have while reading it, here is a collection of
potentially helpful other resources.
      <ul class="itemize1">
      <li class="itemize"><a 
href="https://econ-ark.github.io/HARK/" >Online documentation</a> for HARK tool and model modules, produced using Sphinx.
      </li>
      <li class="itemize">A <a 
href="https://docs.python.org/2.7/tutorial/" >tutorial on Python 2.7</a>, straight from the source.
      </li>
      <li class="itemize"><a 
href="https://en.wikipedia.org/wiki/Object-oriented_programming" >Wikipedia article on object-oriented programming</a>, not the subject of an edit war.
      </li>
      <li class="itemize"><a 
href="http://quant-econ.net/" >QuantEcon</a>, a collection of lectures on quantitative economic modeling from a couple
      of economists, which definitely in no way influenced HARK whatsoever.
      </li>
      <li class="itemize">A <a 
href="https://www.atlassian.com/git/tutorials/" >tutorial on git</a>, the repository management and tracking system used by the HARK
      project, created by Linus Torvalds.
      </li>
      <li class="itemize">A <a 
href="https://guides.github.com/activities/hello-world/" >tutorial on GitHub</a>, a website that provides a useful framework for git that makes
      it significantly more user-friendly, despised by Linus Torvalds.
      </li>
      <li class="itemize"><a 
href="https://en.wikipedia.org/wiki/Linus_Torvalds" >Wikipedia article on Linus Torvalds</a>, just in case.
                                                                                        
                                                                                        
      </li>
      <li class="itemize">The <a 
href="http://www.numpy.org/" >homepage for NumPy</a>, a numerical package extensively used by HARK.
      </li>
      <li class="itemize">The <a 
href="http://www.sphinx-doc.org/" >homepage for Sphinx</a>, a tool for producing HTML documentation.
      </li>
      <li class="itemize">A <a 
href="http://www.econ2.jhu.edu/people/ccarroll/public/lecturenotes/Consumption/" >collection of lecture notes</a> by Chris Carroll, to catch you up on the basics of
      consumption-saving models.
      </li>
      <li class="itemize">A <a 
href="http://www.econ2.jhu.edu/people/ccarroll/SolvingMicroDSOPs/" >particular set of lecture notes</a> by Chris Carroll, explaining many of the numeric
      techniques used in HARK and offering an example of a simple structural model that,
      in a stunning coincidence, is implemented in HARK as an example.
      </li>
      <li class="itemize">A <a 
href="http://www.econ2.jhu.edu/people/ccarroll/BufferStockTheory.pdf" >deep dive</a> into the theoretical foundations of buffer stock saving. Warning: dense.
      </li></ul>
<!--l. 438--><p class="noindent" >
  <h3 class="sectionHead"><span class="titlemark">2  </span> <a 
 id="x1-60002"></a>General Purpose Tools</h3>
<!--l. 438--><p class="noindent" >HARK&#8217;s  root  directory  contains  six  tool
modules,<span class="footnote-mark"><a 
href="HARKmanual5.html#fn5x0"><sup class="textsuperscript">5</sup></a></span><a 
 id="x1-6001f5"></a> 
each containing a variety of functions and classes that can be used in many
economic models&#8211; or even for mathematical purposes that have nothing to do with
economics. Some of the tool modules are very sparely populated at this time, while
others are quite large. We expect that all of these modules will grow considerably
in the near future, as new tools are &#8220;low hanging fruit&#8221; for contribution to the
project.<span class="footnote-mark"><a 
href="HARKmanual6.html#fn6x0"><sup class="textsuperscript">6</sup></a></span><a 
 id="x1-6002f6"></a> 
                                                                                        
                                                                                        
  <h4 class="subsectionHead"><span class="titlemark">2.1  </span> <a 
 id="x1-70002.1"></a>HARKcore</h4>
<!--l. 438--><p class="noindent" >A key goal of the project is to create modularity and interoperability between models, making
them easy to combine, adapt, and extend. To this end, the <span 
class="ectt-1200">HARKcore </span>module specifies a
framework for economic models in HARK, creating a common structure for them on two levels
that can be called &#8220;microeconomic&#8221; and &#8220;macroeconomic&#8221;.
<!--l. 438--><p class="indent" >  Microeconomic models in HARK use the <span 
class="ectt-1200">AgentType </span>class to represent agents with an
intertemporal optimization problem. Each of these models specifies a subclass of <span 
class="ectt-1200">AgentType</span>; an
instance of the subclass represents agents who are <span 
class="ecti-1200">ex-ante </span>homogeneous&#8211; they have common
values for all parameters that describe the problem. For example, <span 
class="ectt-1200">ConsIndShockModel </span>specifies
the <span 
class="ectt-1200">IndShockConsumerType </span>class, which has methods specific to consumption-saving
models with idiosyncratic shocks to income; an instance of the class might represent all
consumers who have a CRRA of 3, discount factor of 0.98, etc. The <span 
class="ectt-1200">AgentType </span>class
has a <span 
class="ectt-1200">solve </span>method that acts as a &#8220;universal microeconomic solver&#8221; for any properly
formatted model, making it easier to set up a new model and to combine elements
from different models; the solver is intended to encompass any model that can be
framed as a sequence of one period problems. For a complete description, see section
<a 
href="#x1-130003">3<!--tex4ht:ref: sec:Microeconomics --></a>.
<!--l. 438--><p class="indent" >  Macroeconomic models in HARK use the <span 
class="ectt-1200">Market </span>class to represent a market (or other
aggregator) that combines the actions, states, and/or shocks (generally, outcomes) of individual
agents in the model into aggregate outcomes that are &#8220;passed back&#8221; to the agents. For example,
the market in a consumption-saving model might combine the individual asset holdings of all
agents in the market to generate aggregate capital in the economy, yielding the interest rate on
assets (as the marginal product of capital); the individual agents then learn the aggregate capital
level and interest rate, conditioning their next action on this information. Objects that
microeconomic agents treat as exogenous when solving (or simulating) their model are thus
endogenous at the macroeconomic level. Like <span 
class="ectt-1200">AgentType</span>, the <span 
class="ectt-1200">Market </span>class also has a
<span 
class="ectt-1200">solve </span>method, which seeks out a dynamic general equilibrium: a &#8220;rule&#8221; governing the
dynamic evolution of macroeconomic objects such that if agents believe this rule and
act accordingly, then their collective actions generate a sequence of macroeconomic
outcomes that justify the belief in that rule. For a more complete description, see section
<a 
href="#x1-180004">4<!--tex4ht:ref: sec:Macroeconomics --></a>.
<!--l. 438--><p class="indent" >  Beyond the model frameworks, <span 
class="ectt-1200">HARKcore </span>also defines a &#8220;supersuperclass&#8221; called <span 
class="ectt-1200">HARKobject</span>.
When solving a dynamic microeconomic model with an infinite horizon (or searching for a
dynamic general equilibrium), it is often required to consider whether two solutions
are sufficiently close to each other to warrant stopping the process (i.e.&#x00A0;approximate
convergence). It is thus necessary to calculate the &#8220;distance&#8221; between two solutions,
so HARK specifies that classes should have a <span 
class="ectt-1200">distance </span>method that takes a single
input and returns a non-negative value representing the (generally dimensionless)
distance between the object in question and the input to the method. As a convenient
default, <span 
class="ectt-1200">HARKobject </span>provides a &#8220;universal distance metric&#8221; that should be useful in many
                                                                                        
                                                                                        
contexts.<span class="footnote-mark"><a 
href="HARKmanual7.html#fn7x0"><sup class="textsuperscript">7</sup></a></span><a 
 id="x1-7001f7"></a> 
When defining a new subclass of <span 
class="ectt-1200">HARKobject</span>, the user simply defines the attribute
<span 
class="ectt-1200">distance_criteria </span>as a list of strings naming the attributes of the class that should be
compared when calculating the distance between two instances of that class. For example, the
class <span 
class="ectt-1200">ConsumerSolution </span>has <span 
class="ectt-1200">distance_criteria = [&#8217;cFunc&#8217;]</span>, indicating that only the
consumption function attribute of the solution matters when comparing the distance between
two instances of <span 
class="ectt-1200">ConsumerSolution</span>. See <a 
href="https://econ-ark.github.io/HARK/generated/HARKcore.html" >here</a> for online documentation.
  <h4 class="subsectionHead"><span class="titlemark">2.2  </span> <a 
 id="x1-80002.2"></a>HARKutilities</h4>
<!--l. 438--><p class="noindent" >The <span 
class="ectt-1200">HARKutilities </span>module carries a double meaning in its name, as it contains both
utility functions (and their derivatives, inverses, and combinations thereof) in the
economic modeling sense as well as utilities in the sense of general tools. Utility functions
included at this time are constant relative risk aversion and constant absolute risk
aversion. Other functions in <span 
class="ectt-1200">HARKutilities </span>include some data manipulation tools
(e.g.&#x00A0;for calculating an average of data conditional on being within a percentile range
of different data), functions for constructing discrete state space grids, convenience
functions for retrieving information about functions, and basic plotting tools using
<span 
class="ectt-1200">matplotlib.pyplot</span>.
<!--l. 438--><p class="indent" >  The module also includes functions for constructing discrete approximations to continuous
distributions (e.g.&#x00A0;<span 
class="ectt-1200">approxLognormal() </span>to approximate a log-normal distribution) as well as
manipulating these representations (e.g.&#x00A0;appending one outcome to an existing distribution, or
combining independent univariate distributions into one multivariate distribution). As a
convention in HARK, continuous distributions are approximated as finite discrete distributions
when solving models; an <img 
src="HARKmanual1x.png" alt="N  "  class="math" >-dimensional random variable is formatted as a length <img 
src="HARKmanual2x.png" alt="N + 1  "  class="math" > list of
1D arrays, with the first element representing event probabilities and all other elements are
realizations of the <img 
src="HARKmanual3x.png" alt="N  "  class="math" > component RVs. This both simplifies solution methods (reducing numeric
integrals to simple dot products) and allows users to easily test whether their chosen degree of
discretization yields a sufficient approximation to the full distribution. See <a 
href="https://econ-ark.github.io/HARK/generated/HARKutilities.html" >here</a> for online
documentation.
<!--l. 438--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">2.3  </span> <a 
 id="x1-90002.3"></a>HARKinterpolation</h4>
<!--l. 438--><p class="noindent" >The <span 
class="ectt-1200">HARKinterpolation </span>module defines classes for representing interpolated function
                                                                                        
                                                                                        
approximations. Interpolation methods in HARK all inherit from a superclass such as
<span 
class="ectt-1200">HARKinterpolator1D </span>or <span 
class="ectt-1200">HARKinterpolator2D</span>, wrapper classes that ensures interoperability
across interpolation methods. For example, <span 
class="ectt-1200">HARKinterpolator1D </span>specifies the methods
<span 
class="ectt-1200">__call__ </span>and <span 
class="ectt-1200">derivative </span>to accept an arbitrary array as an input and return an identically
shaped array with the interpolated function evaluated at the values in the array or its first
derivative, respectively. However, these methods do little on their own, merely reshaping arrays
and referring to the <span 
class="ectt-1200">_evaluate </span>and <span 
class="ectt-1200">_der </span>methods, which are <span 
class="ecti-1200">not actually defined in</span>
<span 
class="ectt-1200">HARKinterpolator1D</span>. Each subclass of <span 
class="ectt-1200">HARKinterpolator1D </span>specifies their own implementation
of <span 
class="ectt-1200">_evaluate </span>and <span 
class="ectt-1200">_der </span>particular to that interpolation method, accepting and returning only 1D
arrays. In this way, subclasses of <span 
class="ectt-1200">HARKinterpolator1D </span>are easily interchangeable with each
other, as all methods that the user interacts with are identical, varying only by &#8220;internal&#8221;
methods.
<!--l. 438--><p class="indent" >  When evaluating a stopping criterion for an infinite horizon problem, it is often necessary to
know the &#8220;distance&#8221; between functions generated by successive iterations of a solution procedure.
To this end, each interpolator class in HARK must define a <span 
class="ectt-1200">distance </span>method that takes as an
input another instance of the same class and returns a non-negative real number representing the
&#8220;distance&#8221; between the two. As each of the <span 
class="ectt-1200">HARKinterpolatorXD </span>classes inherits from
<span 
class="ectt-1200">HARKobject</span>, all interpolator classes have the default &#8220;universal&#8221; distance method; the user must
simply list the names of the relevant attributes in the attribute <span 
class="ectt-1200">distance_criteria </span>of the
class.
<!--l. 438--><p class="indent" >  Interpolation methods currently implemented in HARK include (multi)linear interpolation up
to 4D, 1D cubic spline interpolation, (multi)linear interpolation over 1D interpolations (up to 4D
total), (multi)linear interpolation over 2D interpolations (up to 4D total), linear interpolation
over 3D interpolations, 2D curvilinear interpolation over irregular grids, and a 1D &#8220;lower
envelope&#8221; interpolator. See <a 
href="https://econ-ark.github.io/HARK/generated/HARKinterpolation.html" >here</a> for online documentation.
<!--l. 438--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">2.4  </span> <a 
 id="x1-100002.4"></a>HARKsimulation</h4>
<!--l. 438--><p class="noindent" >The <span 
class="ectt-1200">HARKsimulation </span>module provides tools for generating simulated data or shocks for
post-solution use of models. Currently implemented distributions include normal, lognormal,
Weibull (including exponential), uniform, Bernoulli, and discrete. As an example of their use,
these tools are used in the consumption-saving models of <span 
class="ectt-1200">ConsIndShockModel.py </span>to simulate
permanent and transitory income shocks as well as unemployment events. See <a 
href="https://econ-ark.github.io/HARK/generated/HARKsimulation.html" >here</a> for online
documentation.
<!--l. 438--><p class="noindent" >
                                                                                        
                                                                                        
  <h4 class="subsectionHead"><span class="titlemark">2.5  </span> <a 
 id="x1-110002.5"></a>HARKestimation</h4>
<!--l. 438--><p class="noindent" >Methods for optimizing an objective function for the purposes of estimating a model can be
found in <span 
class="ectt-1200">HARKestimation</span>. As of this writing, the implementation includes only minimization by
the Nelder-Mead simplex method, minimization by a derivative-free Powell method
variant, and two small tools for resampling data (i.e.&#x00A0;for a bootstrap); the minimizers
are merely convenience wrappers (with result reporting) for optimizers included in
<span 
class="ectt-1200">scipy.optimize</span>. Future functionality will include more robust global search methods, including
genetic algorithms, simulated annealing, and differential evolution. See <a 
href="https://econ-ark.github.io/HARK/generated/HARKestimation.html" >here</a> for full
documentation.
<!--l. 438--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">2.6  </span> <a 
 id="x1-120002.6"></a>HARKparallel</h4>
<!--l. 438--><p class="noindent" >By default, processes in Python are single-threaded, using only a single CPU core. The <span 
class="ectt-1200">HARKparallel</span>
module provides basic tools for using multiple CPU cores simultaneously, with minimal
effort.<span class="footnote-mark"><a 
href="HARKmanual8.html#fn8x0"><sup class="textsuperscript">8</sup></a></span><a 
 id="x1-12001f8"></a> 
In particular, it provides the function <span 
class="ectt-1200">multiThreadCommands</span>, which takes two arguments: a list
of <span 
class="ectt-1200">AgentType</span>s and a list of commands as strings; each command should be a method of the
<span 
class="ectt-1200">AgentType</span>s. The function simply distributes the <span 
class="ectt-1200">AgentType</span>s across threads on different cores
and executes each command in order, returning no output (the <span 
class="ectt-1200">AgentType</span>s themselves are
changed by running the commands). Equivalent results would be achieved by simply looping
over each type and running each method in the list. Indeed, <span 
class="ectt-1200">HARKparallel </span>also has a
function called <span 
class="ectt-1200">multiThreadCommandsFake </span>that does just that, with identical syntax to
<span 
class="ectt-1200">multiThreadCommands</span>; multithreading in HARK can thus be easily turned on and
off.<span class="footnote-mark"><a 
href="HARKmanual9.html#fn9x0"><sup class="textsuperscript">9</sup></a></span><a 
 id="x1-12002f9"></a> 
The module also has functions for a parallel implementation of the Nelder-Mead simplex
algorithm, as described in Wiswall and Lee (2011). See <a 
href="https://econ-ark.github.io/HARK/generated/HARKparallel.html" >here</a> for full documentation.
  <h3 class="sectionHead"><span class="titlemark">3  </span> <a 
 id="x1-130003"></a>Microeconomics: the AgentType Class</h3>
<!--l. 438--><p class="noindent" >The core of our microeconomic dynamic optimization framework is a flexible object-oriented
representation of economic agents. The <span 
class="ectt-1200">HARKcore </span>module defines a superclass called <span 
class="ectt-1200">AgentType</span>;
                                                                                        
                                                                                        
each model defines a subclass of <span 
class="ectt-1200">AgentType</span>, specifying additional model-specific features and
methods while inheriting the methods of the superclass. Most importantly, the method <span 
class="ectt-1200">solve</span>
acts as a &#8220;universal solver&#8221; applicable to any (properly formatted) discrete time model. This
section describes the format of an instance of <span 
class="ectt-1200">AgentType </span>as it defines a dynamic microeconomic
problem;<span class="footnote-mark"><a 
href="HARKmanual10.html#fn10x0"><sup class="textsuperscript">10</sup></a></span><a 
 id="x1-13001f10"></a> 
  <h4 class="subsectionHead"><span class="titlemark">3.1  </span> <a 
 id="x1-140003.1"></a>Attributes of an AgentType</h4>
<!--l. 438--><p class="noindent" >A discrete time model in our framework is characterized by a sequence of &#8220;periods&#8221; that the
agent will experience. A well-formed instance of <span 
class="ectt-1200">AgentType </span>includes the following
attributes:
      <ul class="itemize1">
      <li class="itemize"><span 
class="ectt-1200">solveOnePeriod</span>:  A  function,  or  a  list  of  functions,  representing  the  solution
      method  for  a  single  period  of  the  agent&#8217;s  problem.  The  inputs  passed  to  a
      <span 
class="ectt-1200">solveOnePeriod </span>function include all data that characterize the agent&#8217;s problem in
      that period, including the solution to the subsequent period&#8217;s problem (designated
      as <span 
class="ectt-1200">solution_next</span>). The output of these functions is a single <span 
class="ectt-1200">Solution </span>object, which
      can be passed to the solver for the previous period.
      </li>
      <li class="itemize"><span 
class="ectt-1200">time_inv</span>: A list of strings containing all of the variable names that are passed to at
      least one function in <span 
class="ectt-1200">solveOnePeriod </span>but do <span 
class="ecti-1200">not </span>vary across periods. Each of these
      variables resides in a correspondingly named attribute of the <span 
class="ectt-1200">AgentType </span>instance.
      </li>
      <li class="itemize"><span 
class="ectt-1200">time_vary</span>:  A  list  of  strings  naming  the  attributes  of  this  instance  that  vary
      across  periods.  Each  of  these  attributes  is  a  list  of  period-specific  values,  which
      should be of the same length. If the solution method varies across periods, then
      <span 
class="ectt-1200">&#8217;solveOnePeriod&#8217; </span>is an element of <span 
class="ectt-1200">time_vary</span>.<span class="footnote-mark"><a 
href="HARKmanual11.html#fn11x0"><sup class="textsuperscript">11</sup></a></span><a 
 id="x1-14001f11"></a> 
      </li>
      <li class="itemize"><span 
class="ectt-1200">solution_terminal</span>: An object representing the solution to the &#8220;terminal&#8221;  period
      of the model. This might represent a known trivial solution that does not require
      numeric methods, the solution to some previously solved &#8220;next phase&#8221; of the model,
      a scrap value function, or an initial guess of the solution to an infinite horizon model.
                                                                                        
                                                                                        
      </li>
      <li class="itemize"><span 
class="ectt-1200">pseudo_terminal</span>:  A  Boolean  flag  indicating  that  <span 
class="ectt-1200">solution_terminal </span>is  not  a
      proper terminal period solution (rather an initial guess, &#8220;next phase&#8221;  solution, or
      scrap value) and should not be reported as part of the model&#8217;s solution.
      </li>
      <li class="itemize"><span 
class="ectt-1200">cycles</span>:  A  non-negative  integer  indicating  the  number  of  times  the  agent  will
      experience the sequence of periods in the problem. For example, <span 
class="ectt-1200">cycles = 1 </span>means
      that the sequence of periods is analogous to a lifecycle model, experienced once from
      beginning to end; <span 
class="ectt-1200">cycles = 2 </span>means that the agent experiences the sequence twice,
      with the first period in the sequence following the last. An infinite horizon problem
      in which the sequence of periods repeats indefinitely is indicated with <span 
class="ectt-1200">cycles = 0</span>.
      </li>
      <li class="itemize"><span 
class="ectt-1200">tolerance</span>: A positive real number indicating convergence tolerance, representing
      the maximum acceptable &#8220;distance&#8221; between successive cycle solutions in an infinite
      horizon model; it is irrelevant when <span 
class="ectt-1200">cycles &#x003E; 0</span>. As the distance metric on the space
      of solutions is model-specific, the value of <span 
class="ectt-1200">tolerance </span>is generally dimensionless.
      </li>
      <li class="itemize"><span 
class="ectt-1200">time_flow</span>: A Boolean flag indicating the direction that time is &#8220;flowing.&#8221;  When
      <span 
class="ectt-1200">True</span>, the variables listed in <span 
class="ectt-1200">time_vary </span>are listed in ordinary chronological order,
      with index 0 being the first period; when <span 
class="ectt-1200">False</span>, these lists are in reverse chronological
      order, with index 0 holding the last period.</li></ul>
<!--l. 438--><p class="indent" >  An instance of <span 
class="ectt-1200">AgentType </span>also has the attributes named in <span 
class="ectt-1200">time_vary </span>and <span 
class="ectt-1200">time_inv</span>, and
may have other attributes that are not included in either (e.g.&#x00A0;values not used in the model
solution, but instead to construct objects used in the solution).
<!--l. 438--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">3.2  </span> <a 
 id="x1-150003.2"></a>A Universal Solver</h4>
<!--l. 438--><p class="noindent" >When an instance of <span 
class="ectt-1200">AgentType </span>invokes its <span 
class="ectt-1200">solve </span>method, the solution to the agent&#8217;s problem is
stored in the attribute <span 
class="ectt-1200">solution</span>. The solution is computed by recursively solving the sequence of
periods defined by the variables listed in <span 
class="ectt-1200">time_vary </span>and <span 
class="ectt-1200">time_inv </span>using the functions in
<span 
class="ectt-1200">solveOnePeriod</span>. The time-varying inputs are updated each period, including the
successive period&#8217;s solution as <span 
class="ectt-1200">solution_next</span>; the same values of time invariant inputs in
<span 
class="ectt-1200">time_inv </span>are passed to the solver in every period. The first call to <span 
class="ectt-1200">solveOnePeriod </span>uses
<span 
class="ectt-1200">solution_terminal </span>as <span 
class="ectt-1200">solution_next</span>. In a finite horizon problem, the sequence of
periods is solved <span 
class="ectt-1200">cycles </span>times over; in an infinite horizon problem, the sequence of
periods is solved until the solutions of successive cycles have a &#8220;distance&#8221; of less than
<span 
class="ectt-1200">tolerance</span>.
                                                                                        
                                                                                        
<!--l. 438--><p class="indent" >  The output from a function in <span 
class="ectt-1200">solveOnePeriod </span>is an instance of a model-specific solution
class. The attributes of a solution to one period of a problem might include behavioral functions,
(marginal) value functions, and other variables characterizing the result. Each solution class must
have a method called <span 
class="ectt-1200">distance()</span>, which returns the &#8220;distance&#8221; between itself and another
instance of the same solution class, so as to define convergence as a stopping criterion; for many
models, this will be the &#8220;distance&#8221; between a policy or value function in the solutions. If the
solution class is defined as a subclass of <span 
class="ectt-1200">HARKobject</span>, it automatically inherits the default
<span 
class="ectt-1200">distance </span>method, so that the user must only list the relevant object attributes in
<span 
class="ectt-1200">distance_criteria</span>.
<!--l. 438--><p class="indent" >  The <span 
class="ectt-1200">AgentType </span>also has methods named <span 
class="ectt-1200">preSolve </span>and <span 
class="ectt-1200">postSolve</span>, both of which take no
arguments and do absolutely nothing. A subclass of <span 
class="ectt-1200">AgentType </span>can overwrite these blank
methods with its own model specific methods. <span 
class="ectt-1200">preSolve </span>is automatically called near the
beginning of the <span 
class="ectt-1200">solve </span>method, before solving the sequence of periods. It is used for specifying
tasks that should be done before solving the sequence of periods, such as pre-constructing some
objects repeatedly used by the solution method or finding an analytical terminal period solution.
For example, the <span 
class="ectt-1200">IndShockConsumerType </span>class in <span 
class="ectt-1200">ConsIndShockModel </span>has a <span 
class="ectt-1200">preSolve </span>method
that calls its <span 
class="ectt-1200">updateSolutionTerminal </span>method to ensure that <span 
class="ectt-1200">solution_terminal </span>is
consistent with the model parameters. The <span 
class="ectt-1200">postSolve </span>method is called shortly after the
sequence of periods is fully solved; it can be used for &#8220;post-processing&#8221; of the solution or
performing a step that is only useful after solution convergence. For example, the
<span 
class="ectt-1200">TractableConsumerType </span>in <span 
class="ectt-1200">TractableBufferStockModel </span>has a <span 
class="ectt-1200">postSolve </span>method that
constructs an interpolated consumption function from the list of stable arm points found during
solution.
<!--l. 438--><p class="indent" >  Our universal solver is written in a very general way that should be applicable to any discrete
time optimization problem&#8211; because Python is so flexible in defining objects, the time-varying
inputs for each period can take any form. Indeed, the solver does no &#8220;real work&#8221; itself, but merely
provides a structure for describing models in the HARK framework, allowing interoperability
among current and future modules.
<!--l. 438--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">3.3  </span> <a 
 id="x1-160003.3"></a>The Flow of Time and Other Methods</h4>
<!--l. 438--><p class="noindent" >Because dynamic optimization problems are solved recursively in our framework, it is natural to
list time-varying values in reverse chronological order&#8211; the <span 
class="ectt-1200">solve() </span>method loops over the
values in each time-varying list in the same direction that a human would read them.
When simulating agents after the solution has been obtained, however, it is much more
convenient for time-varying parameters to be listed in ordinary chronological order&#8211;
the direction in which they will be experienced by simulated agents. To allow the
user to set the order in which &#8220;time is flowing&#8221; for an instance of <span 
class="ectt-1200">AgentType</span>, the
HARK framework includes functionality to easily change ordering of time-varying
                                                                                        
                                                                                        
values.
<!--l. 438--><p class="indent" >  The attribute <span 
class="ectt-1200">time_flow </span>is <span 
class="ectt-1200">True </span>if variables are listed in ordinary chronological
order and <span 
class="ectt-1200">False </span>otherwise. <span 
class="ectt-1200">AgentType </span>has the following methods for manipulating
time:
      <ul class="itemize1">
      <li class="itemize"><span 
class="ectt-1200">timeReport()</span>: Prints to screen a description of the direction that time is flowing,
      for interactive convenience and as a reminder of the functionality.
      </li>
      <li class="itemize"><span 
class="ectt-1200">timeFlip()</span>:  Flips  the  direction  of  time.  Each  attribute  listed  in  <span 
class="ectt-1200">time_vary </span>is
      reversed in place, and the value of <span 
class="ectt-1200">time_flow </span>is toggled.
      </li>
      <li class="itemize"><span 
class="ectt-1200">timeFwd()</span>: Sets the direction of time to ordinary chronological order.
      </li>
      <li class="itemize"><span 
class="ectt-1200">timeRev()</span>: Sets the direction of time to reverse chronological order.</li></ul>
<!--l. 438--><p class="indent" >  These methods are invoked to more conveniently access time-varying objects. When a new
time-varying attribute is added, its name should be appended to <span 
class="ectt-1200">time_vary</span>, particularly if its
values are used in the solution of the model (or is part of the solution itself). For example, the
<span 
class="ectt-1200">solve() </span>method automatically adds the string <span 
class="ectt-1200">&#8217;solution&#8217; </span>to <span 
class="ectt-1200">time_vary </span>if it is not already
present. Note that attributes listed in <span 
class="ectt-1200">time_vary </span><span 
class="ecti-1200">must </span>be lists if <span 
class="ectt-1200">solve() </span>or <span 
class="ectt-1200">timeFlip()</span>
are used. Some values that could be considered &#8220;time varying&#8221; but are never used to
solve the model are more conveniently represented as a <span 
class="ectt-1200">numpy.array </span>object (e.g.&#x00A0;&#x00A0;the
history of a state or control variable from a simulation); because the <span 
class="ectt-1200">numpy.array</span>
class does not have a <span 
class="ectt-1200">reverse() </span>method, these attributes should not be listed in
<span 
class="ectt-1200">time_vary</span>.
<!--l. 438--><p class="indent" >  The base <span 
class="ectt-1200">AgentType </span>is sparsely defined, as most &#8220;real&#8221; methods will be application-specific.
Two final methods bear mentioning. First, the <span 
class="ectt-1200">__call__ </span>method points to <span 
class="ectt-1200">assignParameters()</span>,
a convenience method for adding or adjusting attributes (inherited from <span 
class="ectt-1200">HARKobject</span>). This
method takes any number of keyword arguments, so that code can be parsimoniously
written as, for example, <span 
class="ectt-1200">AgentInstance(attribute1 = value1, attribute2 =</span>
<span 
class="ectt-1200">value2)</span>. Using Python&#8217;s dictionary capabilities, many attributes can be conveniently
set with minimal code. Second, the <span 
class="ectt-1200">resetRNG </span>method simply resets the <span 
class="ectt-1200">AgentType</span>&#8217;s
random number generator (as the attribute <span 
class="ectt-1200">RNG</span>) using the value in the attribute
<span 
class="ectt-1200">seed</span>.<span class="footnote-mark"><a 
href="HARKmanual12.html#fn12x0"><sup class="textsuperscript">12</sup></a></span><a 
 id="x1-16001f12"></a> 
This method is useful for (<span 
class="ecti-1200">inter alia</span>) ensuring that the same underlying sequence of shocks is
used for every simulation run when a model is solved or estimated.
                                                                                        
                                                                                        
  <h4 class="subsectionHead"><span class="titlemark">3.4  </span> <a 
 id="x1-170003.4"></a>Sample Model: Perfect Foresight Consumption-Saving</h4>
<!--l. 438--><p class="noindent" >To provide a concrete example of how the <span 
class="ectt-1200">AgentType </span>class works, consider the very simple case
of a perfect foresight consumption-saving model. The agent has time-separable, additive CRRA
preferences over consumption, discounting future utility at a constant rate; he receives a
particular stream of labor income each period, and knows the interest rate on assets that he
holds from one period to the next. His decision about how much to consume in a particular
period can be expressed in Bellman form as:
<div class="pic-eqnarray-star">
  <img 
src="HARKmanual4x.png" alt="Vt(Mt )  =  max  u(Ct) + &#x03B2;//Dt E[Vt+1(Mt+1 )],
              Ct
     At  =  Mt  - Ct,

  Mt+1   =  RAt  + Yt+1,
   Yt+1  =  &#x0393; t+1Yt,
             C1- &#x03C1;
  u(C )  =   -----.
             1 - &#x03C1;  " ></div>An
agent&#8217;s problem is thus characterized by values of <img 
src="HARKmanual5x.png" alt="&#x03C1;  "  class="math" >, <img 
src="HARKmanual6x.png" alt="R  "  class="math" >, and <img 
src="HARKmanual7x.png" alt="&#x03B2;  "  class="math" > plus sequences
of survival probabilities <img 
src="HARKmanual8x.png" alt="//Dt  "  class="math" > and income growth factors <img 
src="HARKmanual9x.png" alt="&#x0393; t  "  class="math" > for <img 
src="HARKmanual10x.png" alt="t = 0,&#x22C5;&#x22C5;&#x22C5;,T  "  class="math" >. This
problem has an analytical solution for both the value function and the consumption
function.
<!--l. 438--><p class="indent" >  The <span 
class="ectt-1200">ConsIndShockModel </span>module defines the class <span 
class="ectt-1200">PerfForesightConsumerType</span>
as a subclass of <span 
class="ectt-1200">AgentType </span>and provides solver functions for several
variations of a consumption-saving model, including the perfect foresight
problem.<span class="footnote-mark"><a 
href="HARKmanual13.html#fn13x0"><sup class="textsuperscript">13</sup></a></span><a 
 id="x1-17001f13"></a> 
A HARK user could specify and solve a ten period perfect foresight model with the following
commands:
<!--l. 438--><p class="noindent" ><span 
class="ectt-1200">MyConsumer = PerfForesightConsumerType(time_flow=True, cycles=1,</span>
<!--l. 438--><p class="indent" >   <span 
class="ectt-1200">CRRA = 2.7, Rfree = 1.03, DiscFac = 0.98,</span>
<!--l. 438--><p class="indent" >   <span 
class="ectt-1200">LivPrb = [0.99,0.98,0.97,0.96,0.95,0.94,0.93,0.92,0.91,0.90],</span>
<!--l. 438--><p class="indent" >   <span 
class="ectt-1200">PermGroFac = [1.01,1.01,1.01,1.01,1.01,1.02,1.02,1.02,1.02,1.02],</span>
<!--l. 438--><p class="indent" >   <span 
class="ectt-1200">Nagents=1000)</span>
<!--l. 438--><p class="noindent" ><span 
class="ectt-1200">MyConsumer.solve()</span>
<!--l. 438--><p class="indent" >  The first line makes a new instance of <span 
class="ectt-1200">ConsumerType</span>, specifying that time is currently &#8220;flowing&#8221;
                                                                                        
                                                                                        
forward<span class="footnote-mark"><a 
href="HARKmanual14.html#fn14x0"><sup class="textsuperscript">14</sup></a></span><a 
 id="x1-17002f14"></a> 
and that the sequence of periods happens exactly once; the next three lines (all part of the same
command) set the time invariant (<span 
class="ectt-1200">CRRA</span>, <span 
class="ectt-1200">Rfree</span>, <span 
class="ectt-1200">DiscFac</span>) and time varying parameters (<span 
class="ectt-1200">LivPrb</span>,
<span 
class="ectt-1200">PermGroFac</span>). Note that <span 
class="ectt-1200">dir(MyConsumer) </span>shows all the attributes of <span 
class="ectt-1200">MyConsumer</span>. After running
the <span 
class="ectt-1200">solve </span>method, <span 
class="ectt-1200">MyConsumer </span>will have an attribute called <span 
class="ectt-1200">solution</span>, which will be a list with
eleven <span 
class="ectt-1200">ConsumerSolution </span>objects, representing the period-by-period solution to the
model.<span class="footnote-mark"><a 
href="HARKmanual15.html#fn15x0"><sup class="textsuperscript">15</sup></a></span><a 
 id="x1-17003f15"></a> 
Each <span 
class="ectt-1200">ConsumerSolution </span>has several attributes:
      <ul class="itemize1">
      <li class="itemize"><span 
class="ectt-1200">cFunc</span>:   Optimal   consumption   function   for   this   period   as   a   function   of
      (normalized) market resources <img 
src="HARKmanual11x.png" alt="m   = M  &#x2215;Y
  t     t  t  "  class="math" >. Can be called like any other function:
      <span 
class="ectt-1200">MyConsumer.solution[0].cFunc(5) </span>returns consumption at <img 
src="HARKmanual12x.png" alt="mt = 5  "  class="math" >.
      </li>
      <li class="itemize"><span 
class="ectt-1200">vFunc</span>: Value function (over market resources <img 
src="HARKmanual13x.png" alt="mt  "  class="math" >); can be evaluated like <span 
class="ectt-1200">cFunc</span>.
      </li>
      <li class="itemize"><span 
class="ectt-1200">mNrmMin</span>: Minimum value of normalized market resources <img 
src="HARKmanual14x.png" alt="mt  "  class="math" > such that <span 
class="ectt-1200">cFunc </span>and
      <span 
class="ectt-1200">vFunc </span>are defined.
      </li>
      <li class="itemize"><span 
class="ectt-1200">hNrm</span>: Normalized human wealth&#8211; the PDV of future income (ignoring mortality)
      divided by current period income <img 
src="HARKmanual15x.png" alt="Yt  "  class="math" >.
      </li>
      <li class="itemize"><span 
class="ectt-1200">MPC</span>: The constant marginal propensity to consume (linear consumption function).
      </li></ul>
<!--l. 438--><p class="indent" >  The following command generates the plot for the perfect foresight consumption
function:
<!--l. 438--><p class="noindent" ><span 
class="ectt-1200">mMin = MyConsumer.solution[0].mNrmMin</span>
<!--l. 438--><p class="noindent" ><span 
class="ectt-1200">plotFuncs(MyConsumer.solution[0].cFunc, mMin, mMin+10)</span>
<!--l. 438--><p class="indent" >  To solve a version of this problem in which the sequence of ten periods happens
three times (yielding a <span 
class="ectt-1200">solution </span>attribute with thirty-one elements), the user can
do:
                                                                                        
                                                                                        
<!--l. 438--><p class="noindent" ><span 
class="ectt-1200">MyConsumer(cycles = 3)</span>
<!--l. 438--><p class="noindent" ><span 
class="ectt-1200">MyConsumer.solve()</span>
<!--l. 438--><p class="indent" >  To solve an infinite horizon problem in which the agent experiences the same one period
problem indefinitely, the user can do:
<!--l. 438--><p class="noindent" ><span 
class="ectt-1200">OtherConsumer = PerfForesightConsumerType(cycles=0, CRRA=3.5, Rfree=1.02,</span>
<!--l. 438--><p class="indent" >  <span 
class="ectt-1200">DiscFac=0.95, LivPrb = [0.99], PermGroFac = [1.01], Nagents=1000)</span>
<!--l. 438--><p class="noindent" ><span 
class="ectt-1200">OtherConsumer.solve()</span>
<!--l. 438--><p class="indent" >  This instance is specified as being infinite horizon by setting <span 
class="ectt-1200">cycles=0</span>. Note that the
time-varying inputs are still specified as (one element) lists, even though they take on the same
value in every period; this is because an infinite horizon model might consist of a multi-period
sequence repeated indefinitely, rather than just one repeated period. The <span 
class="ectt-1200">solution </span>attribute of
<span 
class="ectt-1200">OtherConsumer </span>will be a list containing one instance of <span 
class="ectt-1200">ConsumerSolution</span>, representing the
solution to every period of the model.
  <h3 class="sectionHead"><span class="titlemark">4  </span> <a 
 id="x1-180004"></a>Macroeconomics: the Market Class</h3>
<!--l. 438--><p class="noindent" >The modeling framework of <span 
class="ectt-1200">AgentType </span>is deemed &#8220;microeconomic&#8221; because it pertains only to
the dynamic optimization problem of agents, treating all inputs of the problem as
exogenously fixed. In what we label as &#8220;macroeconomic&#8221; models, some of the inputs
for the microeconomic models are endogenously determined by the collective states
and controls of agents in the model. In a dynamic general equilibrium, there must be
consistency between agents&#8217; beliefs about these macroeconomic objects, their individual
behavior, and the realizations of the macroeconomic objects that result from individual
choices.
<!--l. 438--><p class="indent" >  The <span 
class="ectt-1200">Market </span>class in <span 
class="ectt-1200">HARKcore </span>provides a framework for such macroeconomic models, with a
<span 
class="ectt-1200">solve </span>method that searches for a dynamic general equilibrium. An instance of <span 
class="ectt-1200">Market </span>includes a
list of <span 
class="ectt-1200">AgentType</span>s that compose the economy, a method for transforming microeconomic
outcomes (states, controls, and/or shocks) into macroeconomic outcomes, and a method for
interpreting a history or sequence of macroeconomic outcomes into a new &#8220;dynamic rule&#8221; for
agents to believe. Agents treat the dynamic rule as an input to their microeconomic problem,
conditioning their optimal policy functions on it. A dynamic general equilibrium is a fixed point
dynamic rule: when agents act optimally while believing the equilibrium rule, their
individual actions generate a macroeconomic history consistent with the equilibrium
rule.
<!--l. 438--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">4.1  </span> <a 
 id="x1-190004.1"></a>Down on the Farm</h4>
                                                                                        
                                                                                        
<!--l. 438--><p class="noindent" >The <span 
class="ectt-1200">Market </span>class uses a farming metaphor to conceptualize the process for generating a
history of macroeconomic outcomes in a model. Suppose all <span 
class="ectt-1200">AgentTypes </span>in the economy
believe in some dynamic rule (i.e.&#x00A0;the rule is stored as attributes of each <span 
class="ectt-1200">AgentType</span>,
which directly or indirectly enters their dynamic optimization problem), and that they
have each found the solution to their microeconomic model using their <span 
class="ectt-1200">solve </span>method.
Further, the macroeconomic and microeconomic states have been reset to some initial
orientation.
<!--l. 438--><p class="indent" >  To generate a history of macroeconomic outcomes, the <span 
class="ectt-1200">Market </span>repeatedly loops over the
following steps a set number of times:
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x1-19002x1"><span 
class="ectt-1200">sow</span>: Distribute the macroeconomic state variables to all <span 
class="ectt-1200">AgentType</span>s in the market.
      </li>
      <li 
  class="enumerate" id="x1-19004x2"><span 
class="ectt-1200">cultivate</span>:   Each   <span 
class="ectt-1200">AgentType  </span>executes   their   <span 
class="ectt-1200">marketAction  </span>method,   likely
      corresponding to simulating one period of the microeconomic model.
      </li>
      <li 
  class="enumerate" id="x1-19006x3"><span 
class="ectt-1200">reap</span>: Microeconomic outcomes are gathered from each <span 
class="ectt-1200">AgentType </span>in the market.
      </li>
      <li 
  class="enumerate" id="x1-19008x4"><span 
class="ectt-1200">mill</span>: Data gathered by <span 
class="ectt-1200">reap </span>is processed into new macroeconomic states according
      to some &#8220;aggregate market process&#8221;.
      </li>
      <li 
  class="enumerate" id="x1-19010x5"><span 
class="ectt-1200">store</span>: Relevant macroeconomic states are added to a running history of outcomes.</li></ol>
<!--l. 438--><p class="noindent" >This procedure is conducted by the <span 
class="ectt-1200">makeHistory </span>method of <span 
class="ectt-1200">Market </span>as a subroutine of its <span 
class="ectt-1200">solve</span>
method. After making histories of the relevant macroeconomic variables, the market then
executes its <span 
class="ectt-1200">calcDynamics </span>function with the macroeconomic history as inputs, generating a new
dynamic rule to distribute to the <span 
class="ectt-1200">AgentType</span>s in the market. The process then begins again, with
the agents solving their updated microeconomic models given the new dynamic rule; the <span 
class="ectt-1200">solve</span>
loop continues until the &#8220;distance&#8221; between successive dynamic rules is sufficiently
small.
<!--l. 438--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">4.2  </span> <a 
 id="x1-200004.2"></a>Attributes of a Market</h4>
<!--l. 438--><p class="noindent" >To specify a complete instance of <span 
class="ectt-1200">Market</span>, the user should give it the following
attributes:<span class="footnote-mark"><a 
href="HARKmanual16.html#fn16x0"><sup class="textsuperscript">16</sup></a></span><a 
 id="x1-20001f16"></a> 
                                                                                        
                                                                                        
      <ul class="itemize1">
      <li class="itemize"><span 
class="ectt-1200">agents</span>: A list of <span 
class="ectt-1200">AgentType</span>s, representing the agents in the market. Each element in
      <span 
class="ectt-1200">agents </span>represents an <span 
class="ecti-1200">ex-ante </span>heterogeneous type; each type could have many <span 
class="ecti-1200">ex-post</span>
      heterogeneous agents.
      </li>
      <li class="itemize"><span 
class="ectt-1200">sow_vars</span>: A list of strings naming variables that are output from the aggregate
      market process, representing the macroeconomic outcomes. These variables will be
      distributed to the <span 
class="ectt-1200">agents </span>in the <span 
class="ectt-1200">sow </span>step.
      </li>
      <li class="itemize"><span 
class="ectt-1200">reap_vars</span>: A list of strings naming variables to be collected from the <span 
class="ectt-1200">agents </span>in the
      <span 
class="ectt-1200">reap </span>step, to be used as inputs for the aggregate market process.
      </li>
      <li class="itemize"><span 
class="ectt-1200">const_vars</span>: A list of strings naming variables used by the aggregate market process
      that <span 
class="ecti-1200">do not </span>come from <span 
class="ectt-1200">agents</span>; they are constant or come from the <span 
class="ectt-1200">Market </span>itself.
      </li>
      <li class="itemize"><span 
class="ectt-1200">track_vars</span>: A list of strings naming variables generated by the aggregate market
      process that should be tracked as a history, to be used when calculating a new
      dynamic rule. Usually a subset of <span 
class="ectt-1200">sow_vars</span>.
      </li>
      <li class="itemize"><span 
class="ectt-1200">dyn_vars</span>: A list of strings naming the variables that constitute a dynamic rule. These
      will be stored as attributes of the <span 
class="ectt-1200">agents </span>whenever a new rule is calculated.
      </li>
      <li class="itemize"><span 
class="ectt-1200">millRule</span>:   A   function   for   the   &#8220;aggregate   market   process&#8221;,   transforming
      microeconomic  outcomes  into  macroeconomic  outcomes.  Its  inputs  are  named  in
      <span 
class="ectt-1200">reap_vars </span>and <span 
class="ectt-1200">const_vars</span>, and it returns a single object with attributes named in
      <span 
class="ectt-1200">sow_vars </span>and/or <span 
class="ectt-1200">track_vars</span>. Can be defined as a method of a subclass of <span 
class="ectt-1200">Market</span>.
      </li>
      <li class="itemize"><span 
class="ectt-1200">calcDynamics</span>: A function that generates a new dynamic rule from a history of
      macroeconomic outcomes. Its inputs are named in <span 
class="ectt-1200">track_vars</span>, and it returns a single
      object with attributes named in <span 
class="ectt-1200">dyn_vars</span>.
      </li>
      <li class="itemize"><span 
class="ectt-1200">act_T</span>:  The  number  of  times  that  the  <span 
class="ectt-1200">makeHistory </span>method  should  execute  the
      &#8220;farming loop&#8221; when generating a new macroeconomic history.
      </li>
      <li class="itemize"><span 
class="ectt-1200">tolerance</span>: The minimum acceptable &#8220;distance&#8221;  between successive dynamic rules
      produced by <span 
class="ectt-1200">calcDynamics </span>to constitute a sufficiently converged solution.</li></ul>
                                                                                        
                                                                                        
<!--l. 438--><p class="indent" >  Further, each <span 
class="ectt-1200">AgentType </span>in <span 
class="ectt-1200">agents </span>must have two methods not necessary for microeconomic
models; neither takes any input (except <span 
class="ectt-1200">self</span>):
      <ul class="itemize1">
      <li class="itemize"><span 
class="ectt-1200">marketAction</span>: The microeconomic process to be run in the <span 
class="ectt-1200">cultivate </span>step. Likely
      uses the new macroeconomic outcomes named in <span 
class="ectt-1200">sow_vars</span>; should store new values
      of relevant microeconomic outcomes in the attributes (of <span 
class="ectt-1200">self</span>) named in <span 
class="ectt-1200">reap_vars</span>.
      </li>
      <li class="itemize"><span 
class="ectt-1200">reset</span>:  Reset,  initialize,  or  prepare  for  a  new  &#8220;farming  loop&#8221;  to  generate  a
      macroeconomic history. Might reset its internal random number generator, set initial
      state varibles, clear personal histories, etc.</li></ul>
<!--l. 438--><p class="indent" >  When solving macroeconomic models in HARK, the user should also define classes to represent
the output from the aggregate market process in <span 
class="ectt-1200">millRule </span>and for the model-specific
dynamic rule. The latter should have a <span 
class="ectt-1200">distance </span>method to test for solution convergence;
if the class inherits from <span 
class="ectt-1200">HARKobject</span>, the user need only list relevant attributes in
<span 
class="ectt-1200">distance_criteria</span>.
  <h4 class="subsectionHead"><span class="titlemark">4.3  </span> <a 
 id="x1-210004.3"></a>Sample Model: FashionVictim</h4>
<!--l. 438--><p class="noindent" >To illustrate the <span 
class="ectt-1200">Market </span>class, consider a simple example in the emerging economic subfield of aesthemetrics, the
<span 
class="ectt-1200">FashionVictimModel</span>.<span class="footnote-mark"><a 
href="HARKmanual17.html#fn17x0"><sup class="textsuperscript">17</sup></a></span><a 
 id="x1-21001f17"></a> <span class="footnote-mark"><a 
href="HARKmanual18.html#fn18x0"><sup class="textsuperscript">18</sup></a></span><a 
 id="x1-21002f18"></a> 
This module defines a subclass of <span 
class="ectt-1200">AgentType </span>called <span 
class="ectt-1200">FashionVictimType</span>. Each period, fashion
victims make a binary choice of style <img 
src="HARKmanual16x.png" alt="s  "  class="math" >: to dress as a jock (0) or punk (1). They receive utility
directly from the outfit they wear and as a function of the proportion of the population who <span 
class="ecti-1200">just</span>
<span 
class="ecti-1200">wore </span>the same style; they also pay switching costs (<img 
src="HARKmanual17x.png" alt="cpj  "  class="math" >,<img 
src="HARKmanual18x.png" alt="cjp  "  class="math" >) if they change styles rather than
keep the same as the previous period. Moreover, they receive an idiosyncratic type 1 extreme
value (T1EV) preference shock to each style in each period. Defining the population punk
proportion as <img 
src="HARKmanual19x.png" alt="p  "  class="math" > and the conformity utility function as <img 
src="HARKmanual20x.png" alt="f : [0,1] &#x2192; &#x211D;  "  class="math" >, the current period utility
function is thus:
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
                                                                                        
                                                                                        
<img 
src="HARKmanual21x.png" alt="u(s ;s   ,p) = s f(p )+ (1- s )f(1- p )+s  U + (1- s )U  - c s   (1- s )- c (1 - s  )s .
   t  t- 1  t    t   t        t       t    t p       t   j  pj t-1     t    jp     t-1  t
" class="math-display" ></center></td></tr></table>
<!--l. 438--><p class="nopar" >
<!--l. 438--><p class="indent" >  Fashion victims are forward looking and discount future utility at a constant rate of
<img 
src="HARKmanual22x.png" alt="&#x03B2;  "  class="math" > per period. To simplify the analysis, we assume they believe that the population
punk proportion in the next period is a linear function of the punk proportion in the
current period, subject to a uniformly distributed shock. No restrictions are put on
the function <img 
src="HARKmanual23x.png" alt="f  "  class="math" >; fashion victims might be conformists who like to dress the same
as others (<img 
src="HARKmanual24x.png" alt="f&#x2032;(p) &#x003E; 0  "  class="math" >) or hipsters who like to style themselves in the minority
(<img 
src="HARKmanual25x.png" alt="f&#x2032;(p) &#x003C; 0  "  class="math" >).<span class="footnote-mark"><a 
href="HARKmanual19.html#fn19x0"><sup class="textsuperscript">19</sup></a></span><a 
 id="x1-21003f19"></a> 
A fashion victim&#8217;s problem can be written in Bellman form as:
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
<img 
src="HARKmanual27x.png" alt="               [                                          ]

V(st-1,pt) = E  smt&#x2208;a{x0,1}u (st;st-1,pt) + &#x03B7;st + &#x03B2;E [V (st,pt+1)] ,
" class="math-display" ></center></td></tr></table>
<!--l. 438--><p class="nopar" >
  <table 
class="equation-star"><tr><td>
  <center class="math-display" >
<img 
src="HARKmanual28x.png" alt="pt+1 =  apt + b + &#x03C0;t+1,    &#x03C0;t+1 ~  U[- w,w ],    &#x03B7;0,&#x03B7;1 ~ T 1EV.
                                                                                        
                                                                                        
" class="math-display" ></center></td></tr></table>
<!--l. 438--><p class="nopar" >
<!--l. 438--><p class="indent" >  An instance of <span 
class="ectt-1200">FashionVictimType </span>is thus characterized by values of <img 
src="HARKmanual29x.png" alt="Up  "  class="math" >, <img 
src="HARKmanual30x.png" alt="Uj  "  class="math" >, <img 
src="HARKmanual31x.png" alt="cpj  "  class="math" >, <img 
src="HARKmanual32x.png" alt="cjp  "  class="math" >
and a function <img 
src="HARKmanual33x.png" alt="f  "  class="math" >, as well as beliefs about <img 
src="HARKmanual34x.png" alt="pt+1   "  class="math" > as a function of <img 
src="HARKmanual35x.png" alt="pt  "  class="math" > (summarized
by slope <img 
src="HARKmanual36x.png" alt="a  "  class="math" >, intercept <img 
src="HARKmanual37x.png" alt="b  "  class="math" >, and uniform shock width <img 
src="HARKmanual38x.png" alt="w  "  class="math" >). Given this information,
a <span 
class="ectt-1200">FashionVictimType</span>&#8217;s infinite horizon microeconomic model can be solved by
backward induction in a few lines; the &#8220;one period solver&#8221; is given by <span 
class="ectt-1200">solveFashion</span>.
However, while individual agents treat the dynamics of <img 
src="HARKmanual39x.png" alt="pt  "  class="math" > as exogenous, they are
in fact endogenously determined by the actions of all the fashion victims in the
market.<span class="footnote-mark"><a 
href="HARKmanual20.html#fn20x0"><sup class="textsuperscript">20</sup></a></span><a 
 id="x1-21004f20"></a> 
A dynamic general equilibrium of the &#8220;macroeconomic fashion model&#8221; is thus characterized by a
triple of <img 
src="HARKmanual40x.png" alt="(a,b,w)  "  class="math" > such that when fashion victims believe in this &#8220;punk evolution rule&#8221; and act
optimally, their collective fashion choices exhibit this same rule when the model is
simulated.
<!--l. 438--><p class="indent" >  The search for a dynamic general equilibrium is implemented in HARK&#8217;s <span 
class="ectt-1200">Market </span>class with the
following definitions:
<!--l. 438--><p class="noindent" ><span 
class="ectt-1200">sow_vars = [&#8217;pNow&#8217;] </span>(macroeconomic outcome is <img 
src="HARKmanual41x.png" alt="pt  "  class="math" >)
<!--l. 438--><p class="noindent" ><span 
class="ectt-1200">reap_vars = [&#8217;sNow&#8217;] </span>(microeconomic outcomes are <img 
src="HARKmanual42x.png" alt="st  "  class="math" > for many agents)
<!--l. 438--><p class="noindent" ><span 
class="ectt-1200">track_vars = [&#8217;pNow&#8217;] </span>(must track history of <img 
src="HARKmanual43x.png" alt="pt  "  class="math" >)
<!--l. 438--><p class="noindent" ><span 
class="ectt-1200">dyn_vars = [&#8217;pNextSlope&#8217;,&#8217;pNextIntercept&#8217;,&#8217;pNextWidth&#8217;] </span>(dynamic rule <img 
src="HARKmanual44x.png" alt="(a,b,w )  "  class="math" >)
<!--l. 438--><p class="noindent" ><span 
class="ectt-1200">millRule = calcPunkProp </span>(aggregate process: average the style choices of all agents)
<!--l. 438--><p class="noindent" ><span 
class="ectt-1200">calcDynamics = calcFashionEvoFunc </span>(calculate new <img 
src="HARKmanual45x.png" alt="(a,b,w)  "  class="math" > with autoregression of
<img 
src="HARKmanual46x.png" alt="pt  "  class="math" >)
<!--l. 438--><p class="noindent" ><span 
class="ectt-1200">act_T = 1000 </span>(simulate 1000 periods of the fashion market)
<!--l. 438--><p class="noindent" ><span 
class="ectt-1200">tolerance = 0.01 </span>(terminate solution when <img 
src="HARKmanual47x.png" alt="(a,b,w )  "  class="math" > changes by less than 0.01)
<!--l. 438--><p class="indent" >  The <span 
class="ectt-1200">agents </span>attribute has a list of 22 <span 
class="ectt-1200">FashionVictimType</span>s, which vary in their values of <img 
src="HARKmanual48x.png" alt="Up  "  class="math" >
and <img 
src="HARKmanual49x.png" alt="U
 j  "  class="math" >, and their <img 
src="HARKmanual50x.png" alt="f  "  class="math" > functions. The <span 
class="ectt-1200">marketAction </span>method of <span 
class="ectt-1200">FashionVictimType</span>
simulates one period of the microeconomic model: each agent receives style preference
shocks <img 
src="HARKmanual51x.png" alt="&#x03B7;0   "  class="math" > and <img 
src="HARKmanual52x.png" alt="&#x03B7;1   "  class="math" >, sees the current proportion of punks <img 
src="HARKmanual53x.png" alt="pt  "  class="math" > (sown to them as <span 
class="ectt-1200">pNow</span>),
and chooses which style to wear, storing it in the binary array <span 
class="ectt-1200">sNow</span>, an attribute of
<span 
class="ectt-1200">self</span>.
<!--l. 438--><p class="indent" >  The <span 
class="ectt-1200">millRule </span>for this market is extremely simple: it flattens the list of binary arrays of
individual style choices (gathered in the <span 
class="ectt-1200">reap </span>step) and averages them into a new value
of <img 
src="HARKmanual54x.png" alt="pt  "  class="math" >, to be tracked as a history and <span 
class="ectt-1200">sow</span>n back to the <span 
class="ectt-1200">agents </span>to begin the cycle
again. Once a history of 1000 values of <img 
src="HARKmanual55x.png" alt="pt  "  class="math" > has been generated with the <span 
class="ectt-1200">makeHistory</span>
method, we can calculate a new dynamic fashion rule with <span 
class="ectt-1200">calcFashionEvoFunc </span>by
                                                                                        
                                                                                        
regressing <img 
src="HARKmanual56x.png" alt="p
 t  "  class="math" > on <img 
src="HARKmanual57x.png" alt="p
 t- 1   "  class="math" >, approximating <img 
src="HARKmanual58x.png" alt="w  "  class="math" > as twice the standard deviation of prediction
errors.<span class="footnote-mark"><a 
href="HARKmanual21.html#fn21x0"><sup class="textsuperscript">21</sup></a></span><a 
 id="x1-21005f21"></a> 
The new fashion rule is an instance of the simple FashionEvoFunc class, whose only methods are
inherited from <span 
class="ectt-1200">HARKobject</span>.
<!--l. 438--><p class="indent" >  When the <span 
class="ectt-1200">solve </span>method is run, the solver successively solves each agent&#8217;s microeconomic
problem, runs the <span 
class="ectt-1200">makeHistory </span>method to generate a 1000 period history of <img 
src="HARKmanual60x.png" alt="pt  "  class="math" >, and calculates
a new punk evolution rule based on this history; the solver terminates when consecutive rules
differ by less than 0.01 in any dimension.
  <h3 class="sectionHead"><span class="titlemark">5  </span> <a 
 id="x1-220005"></a>Contributing to HARK</h3>
<!--l. 443--><p class="noindent" >This section provides an overview of how users can contribute new code to HARK, what sort of
contributions are most desired, and style conventions for the toolKit. Before attempting to
extend HARK, we strongly recommend that you familiarize yourself with its features and models
by looking at the source code.
<!--l. 445--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">5.1  </span> <a 
 id="x1-230005.1"></a>What Does HARK Want?</h4>
<!--l. 447--><p class="noindent" >The easiest and most straightforward way to contribute to HARK is by writing new general
purpose tools for inclusion in one of the top-level modules. This might be a commonly
known data analysis technique (e.g.&#x00A0;a kernel density estimator) for <span 
class="ectt-1200">HARKutilities</span>, an
optimization method (local or global) for <span 
class="ectt-1200">HARKestimation</span>, an interpolation method for
<span 
class="ectt-1200">HARKinterpolation</span>, etc. If you&#8217;ve found a technique useful in your own research and
believe it could be of use to others on entirely different projects, then it probably
belongs in HARK. Likewise, if you read through a HARK module expecting to find a
certain tool or function (because of similar functions that are present, or merely because
<span 
class="ecti-1200">it&#8217;s very useful</span>) but don&#8217;t, this is a good sign that HARK has a hole that you can
fill.<span class="footnote-mark"><a 
href="HARKmanual22.html#fn22x0"><sup class="textsuperscript">22</sup></a></span><a 
 id="x1-23001f22"></a> 
<!--l. 449--><p class="indent" >  Secondly, the development team wants to expand HARK to include more canonical models.
Most of the models available in the toolKit at the time of its public beta release concern agents
with (geometrically discounted) CRRA utility over a unitary consumption good, who receive
                                                                                        
                                                                                        
permanent and transitory shocks to income and have access to a single risk free asset. This is an
important class of models, but that description has an awful lot of qualifiers. In short, there are
many more common features of dynamic household models that are not yet in HARK, but would
be very valuable for the toolKit. New model contributions should &#8220;play nicely&#8221; with existing
models and tools, following HARK style guidelines (see sections 5.4 and 5.5) to the
greatest extent possible. For ideas of potential model extensions for HARK, see section
<a 
href="#x1-300006.2">6.2<!--tex4ht:ref: sec:FutureModels --></a>.<span class="footnote-mark"><a 
href="HARKmanual23.html#fn23x0"><sup class="textsuperscript">23</sup></a></span><a 
 id="x1-23002f23"></a> 
<!--l. 451--><p class="indent" >  Finally, contributions to HARK are not restricted to entirely new functionality. While we have
done our best to provide flexible frameworks and useful tools, we have almost certainly
overlooked an unexpected case that would not be (properly) handled by the toolKit as is.
Moreover, there might even be flaws in our solution or simulation methods. If you find a mistake
or error, we strongly encourage you to contribute a fix for the problem, or at least to flag it as
an Issue on GitHub so that someone else might. The &#8220;mistake&#8221; you find might not
even be in the code itself, but a deficiency in the documentation: a misnamed (or
incorrectly typed) parameter or return variable in the docstring, an incorrect (or missing)
comment, even a grammatical or spelling error. No matter how niggling, we want your
fix.
<!--l. 453--><p class="indent" >  For those who want to contribute to the HARK project without programming a new model or
digging through the code for errors and omissions, consider reading through the Issues page on
GitHub to see what other users have flagged for development. You might find several pieces of
&#8220;low hanging fruit&#8221; for you to quickly fix.
  <h4 class="subsectionHead"><span class="titlemark">5.2  </span> <a 
 id="x1-240005.2"></a>Git and GitHub</h4>
<!--l. 457--><p class="noindent" >Git is a distributed version control system that has gained increasing popularity in the decade
since its creation; it is designed to enable collaboration and &#8220;non-linear workflow&#8221; among a
(potentially disperse) programming team. As HARK is to be developed by volunteer researchers
all around the world, git is an excellent fit for the toolKit. Originally designed by Linus Torvalds
as a command line tool, others have since extended git with further functionality and
a user interface more friendly to those more familiar with GUIs. Foremost among
these tools is GitHub.com, where the HARK project is hosted. This section provides a
brief overview of how to use GitHub to interact with (and potentially contribute to)
HARK.
<!--l. 459--><p class="indent" >  To prepare to contribute to HARK, follow these simple steps:
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x1-24002x1"><span 
class="ecbx-1200">Make  a  GitHub  account:  </span>Go  to  <a 
href="https://www.github.com" >github.com</a>;  the  homepage  should  prompt
      you  to  choose  a  username  and  password.  Signing  up  is  quick,  easy,  and
                                                                                        
                                                                                        
      free.<span class="footnote-mark"><a 
href="HARKmanual24.html#fn24x0"><sup class="textsuperscript">24</sup></a></span><a 
 id="x1-24003f24"></a> 
      </li>
      <li 
  class="enumerate" id="x1-24005x2"><span 
class="ecbx-1200">Install GitHub Desktop</span>: Go to <a 
href="https://desktop.github.com/" >desktop.github.com</a> and download the Desktop
      application for your operating system, then install it. After opening Desktop for the
      first time, enter your GitHub login to connect it to your account.
      </li>
      <li 
  class="enumerate" id="x1-24007x3"><span 
class="ecbx-1200">Fork the HARK repository: </span>Go to the <a 
href="https://github.com/econ-ark/HARK" >HARK repository page</a>, click on the Fork
      button in the upper right, and choose to fork HARK to your own GitHub account.
      This creates a new repository identical to the one hosted by Econ-Ark at the moment
      you fork it, but hosted on your account instead.
      </li>
      <li 
  class="enumerate" id="x1-24009x4"><span 
class="ecbx-1200">Add the repository to Desktop: </span>Open GitHub Desktop, click on the <img 
src="HARKmanual61x.png" alt="+  "  class="math" > icon
      in the upper left, and select clone. Find the repository named <span 
class="ectt-1200">yourusername/HARK</span>,
      click the Clone button at the bottom of the dialogue window, and choose a directory
      on your local machine.</li></ol>
<!--l. 470--><p class="indent" >  You now control a &#8220;fork&#8221; of the main HARK repository, hosted by GitHub, and have a clone of
this fork on your local machine. You are free to edit your fork of HARK in any way you&#8217;d like;
other GitHub users can view your fork (and fork it themselves), but they cannot make changes to
your fork unless you give them permission by adding them as a contributor. Changes made
to the local copy of your fork do not get automatically sent to the remote copy on
GitHub for public viewing. To make changes to your fork on GitHub, follow these
steps:
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x1-24011x1"><span 
class="ecbx-1200">Make local changes: </span>Edit your local copy of the repository in any way you&#8217;d like:
      add or delete lines from existing files; add, delete, or rename entire files or directories.
      </li>
      <li 
  class="enumerate" id="x1-24013x2"><span 
class="ecbx-1200">Commit local changes: </span>Open the repository in GitHub Desktop and click on the
      Changes tab. In the lower left, provide a short description of the changes made in
      the Summary field, and (optionally) longer comments about these changes in the
      Description field. Click the check-mark Commit button.
      </li>
      <li 
  class="enumerate" id="x1-24015x3"><span 
class="ecbx-1200">Push the commit: </span>Click on the Sync button near the upper right to &#8220;push&#8221; your
      local commits to the remote server; this will also pull down remote commits from
      other contributors to your fork that were made since the last time you synced.</li></ol>
                                                                                        
                                                                                        
<!--l. 479--><p class="indent" >  The left hand panel of the Changes tab has a summary of the files that have been changed,
added, or removed since your last commit; the right hand panel shows the specific
changes made to each changed file. After step 2, a record of your changes has been
stored locally by the git system, but is not yet reflected in the public remote copy on
GitHub.<span class="footnote-mark"><a 
href="HARKmanual25.html#fn25x0"><sup class="textsuperscript">25</sup></a></span><a 
 id="x1-24016f25"></a> 
The &#8220;timeline&#8221; summary of the repository at the top of the Desktop window shows the history of
commits for the repository: each dot represents a commit that was pushed to the remote server,
and each open ring represents a local commit that has not been pushed to the remote server;
the large broken ring on the far right represents changes that have not been locally
committed.<span class="footnote-mark"><a 
href="HARKmanual26.html#fn26x0"><sup class="textsuperscript">26</sup></a></span><a 
 id="x1-24017f26"></a> 
The History tab lists all previous commits, including the timestamp, contributor, and a record of
changes made.
<!--l. 481--><p class="indent" >  Suppose you have mucked about in your fork for a while and have made changes to HARK
that you think should be included in the main repository hosted by Econ-Ark. To make your
dream a reality, follow these steps:
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x1-24019x1"><span 
class="ecbx-1200">Isolate the changes: </span>If you mucked around for quite a while, making various changes
      here and there, and then later made some contribution that you want to include in
      the main repository, you should <span 
class="ecti-1200">isolate the desired changes in a new branch of your</span>
      <span 
class="ecti-1200">fork</span>. Make a new branch by clicking the button toward the upper left of GitHub
      Desktop, revert that branch to the commit just before you forked from the main
      repository,<span class="footnote-mark"><a 
href="HARKmanual27.html#fn27x0"><sup class="textsuperscript">27</sup></a></span><a 
 id="x1-24020f27"></a> 
      then edit this branch to include <span 
class="ecti-1200">only the changes you want to push to the main</span>
      <span 
class="ecti-1200">repository</span>.
      </li>
      <li 
  class="enumerate" id="x1-24022x2"><span 
class="ecbx-1200">Issue a pull request: </span>Go to <a 
href="https://github.com/econ-ark/HARK" >HARK&#8217;s GitHub page</a> and click the &#8220;New pull request&#8221;
      button. Click the text that says &#8220;compare across forks&#8221;, and select <span 
class="ectt-1200">econ-ark/HARK</span>
      as the base fork, <span 
class="ectt-1200">master </span>as the base, your fork as the head fork, and the branch to
      be merged as the &#8220;compare&#8221;. In the boxes below, give a name to your pull request
      and provide sufficient comments about your contribution so that a development team
      member can understand what you&#8217;ve done. Click the &#8220;Create pull request&#8221; button.
      </li>
                                                                                        
                                                                                        
      <li 
  class="enumerate" id="x1-24024x3"><span 
class="ecbx-1200">Be patient: </span>Someone from the development team will look at your contribution and
      either merge it into the main repository or return it with comments. See section <a 
href="#x1-250005.3">5.3<!--tex4ht:ref: sec:SubmissionApprovalProcess --></a>
      for procedures followed by the HARK team when evaluating outside contributions.
      </li></ol>
  <h4 class="subsectionHead"><span class="titlemark">5.3  </span> <a 
 id="x1-250005.3"></a>Submission Approval Process</h4>
<!--l. 493--><p class="noindent" >Before submitting to HARK, the development team would like you to make sure that
your intended contribution is listed as an Issue on the GitHub page. If you are going
to fix or address an Issue that is already posted, reply to that post with a note
indicating that you are about to work on it and an estimate of when you will make a
pull request for it. If you want to do something that no one has mentioned yet as
an Issue, make a new Issue on GitHub (briefly) describing what you intend to
do.<span class="footnote-mark"><a 
href="HARKmanual28.html#fn28x0"><sup class="textsuperscript">28</sup></a></span><a 
 id="x1-25001f28"></a> 
This will both help prevent two people from working on the same thing (and one of them
potentially wasting time on it), and lets the development team know what&#8217;s coming. Moreover, if
you propose a contribution that is (a) already in HARK, (b) not in the spirit of HARK, or (c) a
fix for something that&#8217;s not actually broken, this gives the team a chance to let you know not to
spend effort on it.
<!--l. 495--><p class="indent" >  After creating a pull request to submit your contribution, it will be evaluated by one or more
members of the HARK team. Criteria that the HARK team will consider when choosing whether
to accept a submission include:
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x1-25003x1"><span 
class="ecbx-1200">Does the contribution break previous code? </span>If you change or expand an existing
      function, you should make sure that this does not cause some models or applications
      to work incorrectly. In the near future, HARK will have a core set of tests to run to
      check for full compatibility.
      </li>
      <li 
  class="enumerate" id="x1-25005x2"><span 
class="ecbx-1200">Is the code well documented? </span>Code submissions should have properly formatted
      docstrings for each new function, class, method, and module (see section <a 
href="#x1-270005.5">5.5<!--tex4ht:ref: sec:DocumentationConventions --></a>) and
      enough comments for a reader to follow the algorithm.
      </li>
      <li 
  class="enumerate" id="x1-25007x3"><span 
class="ecbx-1200">Is  the  contribution  relevant? </span>The  development  team  intends  for  HARK  to
      be  diverse,  but  not  everything  goes  in  HARK.  If  your  submission  concerns  a
      representative agent model or a method for estimating a reduced form model, then
      it probably doesn&#8217;t belong in HARK.
                                                                                        
                                                                                        
      </li>
      <li 
  class="enumerate" id="x1-25009x4"><span 
class="ecbx-1200">Is the code demonstrated with an example? </span>If your solve a new model in
      HARK, you should include a set of example parameters for other users to easily
      test.  If  you&#8217;ve  contributed  a  new  function,  consider  providing  a  snippet  of  code
      demonstrating its use.<span class="footnote-mark"><a 
href="HARKmanual29.html#fn29x0"><sup class="textsuperscript">29</sup></a></span><a 
 id="x1-25010f29"></a> 
      </li>
      <li 
  class="enumerate" id="x1-25012x5"><span 
class="ecbx-1200">Is the code correct? </span>Your code should actually do what it claims to do.
      </li>
      <li 
  class="enumerate" id="x1-25014x6"><span 
class="ecbx-1200">Does the code use HARK conventions? </span>To the best of your ability, contributions
      to  HARK  should  follow  the  style  guidelines  in  section  <a 
href="#x1-260005.4">5.4<!--tex4ht:ref: sec:NamingConventions --></a>.  We  don&#8217;t  demand
      perfection, as these are guidelines rather than rules.
      </li>
      <li 
  class="enumerate" id="x1-25016x7"><span 
class="ecbx-1200">Is the code well integrated in HARK? </span>In the beta release of HARK, we have
      tried to present a &#8220;taxonomy&#8221; of consumption-saving models that build up from each
      other. When possible, new models in HARK should try to continue this pattern. A
      submission that introduces a model in a new module that could have easily been made
      as an extension of an existing module might be rejected. However, we acknowledge
      that there is value in providing a solver for a new model, and that a future contributor
      might make her mark by integrating it into the existing hierarchy.
      </li>
      <li 
  class="enumerate" id="x1-25018x8"><span 
class="ecbx-1200">Is this already in HARK? </span>If your contribution is already in HARK, then it will
      almost certainly be rejected. Of course, if you submit a version that dominates the
      existing implementation (or even one that works better in a well described, non-trivial
      set of circumstances), it belongs in HARK.</li></ol>
<!--l. 514--><p class="indent" >  The HARK team intends to release more specific guidelines in the near future, so that contributors
are better able to judge their submissions before issuing a pull request. We are in the process of
recruiting &#8220;czars&#8221; to oversee particular aspects of HARK, providing their knowledge and
expertise.<span class="footnote-mark"><a 
href="HARKmanual30.html#fn30x0"><sup class="textsuperscript">30</sup></a></span><a 
 id="x1-25019f30"></a> 
While czars might directly evaluate submissions as a HARK team member, their more important
role is to help establish these guidelines for their domain, more specifically nailing down what we
mean by &#8220;correct&#8221; or &#8220;well integrated&#8221;.
                                                                                        
                                                                                        
  <h4 class="subsectionHead"><span class="titlemark">5.4  </span> <a 
 id="x1-260005.4"></a>Naming Conventions</h4>
<!--l. 518--><p class="noindent" >Object naming conventions in HARK are fairly different than existing standards, and differ
somewhat between tool modules vs model or application modules. The following conventions
apply throughout HARK:
      <ul class="itemize1">
      <li class="itemize">Functions and methods are always in &#8220;camel case&#8221;: no underscores, first letter is lower
      case, first letter of each subsequent word is capitalized. E.g. <span 
class="ectt-1200">approxLognormal</span>.
      </li>
      <li class="itemize">Function  and  method  names  should  accurately  and  concisely  describe  what  the
      function does; the first word in the name <span 
class="ecti-1200">must be a verb</span>.<span class="footnote-mark"><a 
href="HARKmanual31.html#fn31x0"><sup class="textsuperscript">31</sup></a></span><a 
 id="x1-26001f31"></a> 
      </li>
      <li class="itemize">Variable and class names <span 
class="ecti-1200">should not </span>have a verb as their first word.
      </li>
      <li class="itemize">Class names should use no underscores and capitalize the first letter of each word;
      moreover, a class name <span 
class="ecti-1200">must include a noun</span>. E.g.&#x00A0;<span 
class="ectt-1200">ConsPerfForesightSolver</span>.</li></ul>
<!--l. 529--><p class="indent" >  When naming variables in model modules, the HARK team strongly discourages using single
letter names, like <span 
class="ectt-1200">c </span>for consumption. Instead, we encourage contributors to use longer, more
descriptive variable names using additional words and common abbreviations to specify the
variable more precisely. In <span 
class="ectt-1200">/Documentation/NARK.pdf</span>, we list standard single letter variable
&#8220;bases&#8221; and an array of prefixes and suffixes to adjust them. Economic variables in model
modules should (usually) not use underscores, instead using camel case to the greatest extent
possible.<span class="footnote-mark"><a 
href="HARKmanual32.html#fn32x0"><sup class="textsuperscript">32</sup></a></span><a 
 id="x1-26002f32"></a> 
The development team prefers this standard so that users can translate between Python code
and LaTeX script with minimal work.
<!--l. 531--><p class="indent" >  Conventions for naming variables in HARK&#8217;s tool modules are significantly closer to more
commonly used standards. Variable names should be in all lower case, with underscores between
words, e.g.&#x00A0;<span 
class="ectt-1200">data_to_match</span>. The functions and classes in these modules are more general
and almost surely do not have any inherent &#8220;economic content&#8221;; they are numerical
or algorithmic objects, not variables that might appear in an equation in an article
for a (non-computational) economics journal. Variable names in application modules
(e.g.&#x00A0;the files that execute the <span 
class="ectt-1200">cstwMPC </span>estimations) are a mix of the conventions for tool
and model files, as appropriate for each variable. That is, variables that are directly
related to &#8220;economic variables&#8221; in model modules should follow those conventions, while
objects created solely for data manipulation or reporting should use the style of tool
modules.
                                                                                        
                                                                                        
  <h4 class="subsectionHead"><span class="titlemark">5.5  </span> <a 
 id="x1-270005.5"></a>Documentation Conventions</h4>
<!--l. 535--><p class="noindent" >The HARK team wants the toolKit to be as accessible to users as possible; our greatest
fear<span class="footnote-mark"><a 
href="HARKmanual33.html#fn33x0"><sup class="textsuperscript">33</sup></a></span><a 
 id="x1-27001f33"></a>  is
that a new user will open up our code, get hopelessly confused trying to read it, and then never
look at HARK again. To prevent this tragic outcome, we have tried hard to provide
comprehensive, accurate documentation and comments within the code describing our
methods.<span class="footnote-mark"><a 
href="HARKmanual34.html#fn34x0"><sup class="textsuperscript">34</sup></a></span><a 
 id="x1-27002f34"></a> 
Moreover, HARK uses the Sphinx utility to generate a website with <a 
href="https://econ-ark.github.io/HARK/" >online documentation</a> for all
of our tool and model modules, so that users can learn about what&#8217;s available in HARK without
digging through the source code. When making contributions to HARK, the development team
asks users to format their inline documentation to work with Sphinx by following a few simple
rules.
      <ul class="itemize1">
      <li class="itemize">The top of every module should begin with a &#8220;docstring&#8221; providing a clear description
      of  the  contents  of  the  module.  The  first  sentence  should  concisely  summarize
      the  file,  as  it  may  appear  in  an  index  or  summary  of  all  modules  without  the
      remaining  sentences.  A  docstring  at  the  top  of  a  module  should  be  formatted
      as:<span class="footnote-mark"><a 
href="HARKmanual35.html#fn35x0"><sup class="textsuperscript">35</sup></a></span><a 
 id="x1-27003f35"></a> 
      <!--l. 540--><p class="noindent" ><span 
class="ectt-1200">"""</span>
      <!--l. 542--><p class="noindent" ><span 
class="ectt-1200">Specifies an economic model and provides methods for solving it. More</span>
      <span 
class="ectt-1200">specific description of the key features of the model and variations</span>
      <span 
class="ectt-1200">of it in this module. Maybe some comments about the solution method</span>
      <span 
class="ectt-1200">or limitations of the model. Your bank account routing number.</span>
      <!--l. 544--><p class="noindent" ><span 
class="ectt-1200">"""</span>
      </li>
      <li class="itemize">The line directly below the declaration of a function, method or class should begin a
      docstring describing that object. As with modules, the first sentence should concisely
      summarize the function or class, as it might be included in an index or summary. For
      functions and methods, the docstring should be formatted as:
      <!--l. 548--><p class="noindent" ><span 
class="ectt-1200">def functionName(input1,input2):</span>
                                                                                        
                                                                                        
      <!--l. 550--><p class="noindent" >&#x00A0;&#x00A0;       <span 
class="ectt-1200">"""</span>
      <!--l. 552--><p class="noindent" >&#x00A0;&#x00A0;       <span 
class="ectt-1200">Concise description of the function. More details about what</span>
      <!--l. 554--><p class="noindent" >&#x00A0;&#x00A0;       <span 
class="ectt-1200">the function does, options or modes available, and maybe</span>
      <span 
class="ectt-1200">mathematical</span>
      <!--l. 556--><p class="noindent" >&#x00A0;&#x00A0;       <span 
class="ectt-1200">methods used. Credit to a source if you poached their</span>
      <span 
class="ectt-1200">algorithm.</span>
      <!--l. 560--><p class="noindent" >&#x00A0;&#x00A0;       <span 
class="ectt-1200">Parameters</span>
      <!--l. 562--><p class="noindent" >&#x00A0;&#x00A0;       <span 
class="ectt-1200">&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;</span>
      <!--l. 564--><p class="noindent" >&#x00A0;&#x00A0;       <span 
class="ectt-1200">input1: type</span>
      <!--l. 566--><p class="noindent" >&#x00A0;&#x00A0;&#x00A0;&#x00A0;             <span 
class="ectt-1200">Description of what input1 represents.</span>
      <!--l. 568--><p class="noindent" >&#x00A0;&#x00A0;       <span 
class="ectt-1200">input2: type</span>
      <!--l. 570--><p class="noindent" >&#x00A0;&#x00A0;&#x00A0;&#x00A0;             <span 
class="ectt-1200">Description of what input2 represents.</span>
      <!--l. 574--><p class="noindent" >&#x00A0;&#x00A0;       <span 
class="ectt-1200">Returns</span>
      <!--l. 576--><p class="noindent" >&#x00A0;&#x00A0;       <span 
class="ectt-1200">&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;&#8211;</span>
      <!--l. 578--><p class="noindent" >&#x00A0;&#x00A0;       <span 
class="ectt-1200">output_name: type</span>
      <!--l. 580--><p class="noindent" >&#x00A0;&#x00A0;&#x00A0;&#x00A0;             <span 
class="ectt-1200">Description of the output(s) of the function. Might have</span>
      <!--l. 582--><p class="noindent" >&#x00A0;&#x00A0;&#x00A0;&#x00A0;             <span 
class="ectt-1200">multiple entries. If no output, this is just "None".</span>
      <!--l. 584--><p class="noindent" >&#x00A0;&#x00A0;       <span 
class="ectt-1200">"""</span>
      </li>
      <li class="itemize">Provide ample comments within a function or method so that a relatively intelligent
      reader can follow along with your algorithm. Short comments can follow at the end
      of a line, longer comments (or descriptions of the step or task about to be performed)
      should precede a block of code on the line(s) above it.</li></ul>
<!--l. 589--><p class="indent" >  Finally, if you write a new model module, the HARK team asks that you also provide a short
mathematical writeup of the model as a PDF. This document does not need to go into great
detail about the solution method for the model or the functions and classes included in
the module, merely specify the economic model and provide a summary of how it
is solved. See <span 
class="ectt-1200">/Documentation/ConsumptionSavingModels.pdf </span>for an example of
this.
                                                                                        
                                                                                        
  <h3 class="sectionHead"><span class="titlemark">6  </span> <a 
 id="x1-280006"></a>Future of HARK</h3>
<!--l. 665--><p class="noindent" >HARK is in a state of perpetual incompleteness, always expanding to include more
tools and more models. As an open source project in the hands of many contributors
around the world, the HARK team cannot fully predict future features of the toolKit.
This section provides an overview of what we would like to see in the near future, as
well as potential mechanisms to encourage researchers to contribute their code to the
project.
<!--l. 665--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">6.1  </span> <a 
 id="x1-290006.1"></a>Future Tools</h4>
<!--l. 665--><p class="noindent" >The current frameworks in <span 
class="ectt-1200">HARKcore </span>concern agents who have &#8220;isolated&#8221; dynamic
problems or interact with each other only through aggregate outcomes to which they
contribute atomically. We hope to eventually provide a framework for models in which
agents directly interact with each other; this may include a system for specifying the
state of networks and how connections are formed and broken. <span 
class="ectt-1200">HARKcore </span>might also
develop a framework more suited to industrial organization models and dynamic
games.<span class="footnote-mark"><a 
href="HARKmanual36.html#fn36x0"><sup class="textsuperscript">36</sup></a></span><a 
 id="x1-29001f36"></a> 
<!--l. 665--><p class="indent" >  The <span 
class="ectt-1200">HARKestimation </span>module in particular is very sparsely populated, with its functions
mostly serving as wrappers for &#8220;off the shelf&#8221; optimization methods from <span 
class="ectt-1200">scipy.optimize</span>. There
are plenty of non-standard or more complex optimization techniques available, including global
and/or stochastic search methods. We believe that additional optimizers are &#8220;low hanging fruit&#8221;
as straightforward contributions to HARK and thus will be added in the near future. Moreover,
there are plenty of distributions that have no approximator in <span 
class="ectt-1200">HARKutilities </span>(or data generator
in <span 
class="ectt-1200">HARKsimulation</span>), and these functions are among the easiest for new contributors
to write. The data analysis tools in <span 
class="ectt-1200">HARKutilities </span>only include functions that we
happened to use for our current research projects, and we expect that this will be the
mode of growth for future tools. There are some obvious holes that we believe will be
filled quite quickly; for example, we provide a rudimentary non-parametric kernel
regression function, but have not written a kernel density estimator to generate PDFs from
data.
<!--l. 665--><p class="indent" >  The classes currently in <span 
class="ectt-1200">HARKinterpolation </span>are all variations on linear (or
cubic) spline interpolation, and each is specifically written for a fixed number
of dimensions. As these methods use full tensor grids, they are highly impractical
for representing functions in higher dimensions, suffering greatly from the curse of
                                                                                        
                                                                                        
dimensionality.<span class="footnote-mark"><a 
href="HARKmanual37.html#fn37x0"><sup class="textsuperscript">37</sup></a></span><a 
 id="x1-29002f37"></a> 
We are quite confident that <span 
class="ectt-1200">HARKinterpolation </span>will soon include techniques more applicable to
high dimensional state spaces, including Smolnyak interpolation, other (adaptive) sparse grid
methods, and regression-based interpolation. For lower-dimensional spaces, HARK will also soon
provide Delaunay interpolation classes.
<!--l. 665--><p class="indent" >  The <span 
class="ectt-1200">HARKparallel </span>module currently provides a simple interface for handling <span 
class="ecti-1200">ex-ante</span>
heterogeneity among agents. While useful for speeding up moderately-sized problems, the
libraries used are only able to access the CPU of the local machine running the code. In the very
near future, the HARK team will provide an interface (and example) for using Apache Spark,
which bills itself as a &#8220;fast and general engine for large-scale data processing&#8221;. Specifically, users
will be able to easily scale up their computing resources and run HARK code on an Amazon EC2
session or other cluster.
  <h4 class="subsectionHead"><span class="titlemark">6.2  </span> <a 
 id="x1-300006.2"></a>Future Models</h4>
<!--l. 665--><p class="noindent" >The economics models currently included in HARK mostly concern consumption-saving problems
with constant relative risk aversion consumers who experience fully permanent and fully
transitory shocks to income. This is obviously a very small subset of all consumption-saving
models (which are themselves a small subset of all dynamic models economists might be
interested in). Consider some examples of variants, features, and extensions that are not included
in HARK, but could be in the future:
      <ul class="itemize1">
      <li class="itemize">Consumers with other utility functions, such as CARA or expo-power.
      </li>
      <li class="itemize">Consumers with time-inconsistent preferences, e.g.&#x00A0;hyperbolic discounting.
      </li>
      <li class="itemize">Income shocks that are neither fully transitory nor fully permanent.
      </li>
      <li class="itemize">Consumers with a bequest motive or terminal utility function.
      </li>
      <li class="itemize">Utility from leisure and endogenous labor supply.
      </li>
      <li class="itemize">Investment in a durable consumption good such as housing.
                                                                                        
                                                                                        
      </li>
      <li class="itemize">Exogenous shocks to expenses.
      </li>
      <li class="itemize">Multiple consumption goods, as with endogenous medical care.
      </li>
      <li class="itemize">Portfolio allocation between a risky and riskless asset.
      </li>
      <li class="itemize">Job search intensity as a control variable.
      </li>
      <li class="itemize">Endogenous health evolution and health investment.</li></ul>
<!--l. 665--><p class="indent" >  The HARK team is currently developing a module for mixing discrete and continuous
choice models, in the style of Jorgensen, Rust, Iskhakov, and Schjerning (2015). Among
many other models, this framework will enable HARK users to easily develop features
like:
      <ul class="itemize1">
      <li class="itemize">Labor supply on the extensive margin: the timing of retirement.
      </li>
      <li class="itemize">Selection of job type or sector (by riskiness, specific human capital, etc).
      </li>
      <li class="itemize">Choice of medical insurance contract.
      </li>
      <li class="itemize">Decision to rent or own housing.
      </li>
      <li class="itemize">Endogenous default on debt (with &#8220;macroeconomic&#8221; pricing of debt).
      </li>
      <li class="itemize">Household formation, dissolution, and reproduction.</li></ul>
<!--l. 665--><p class="indent" >  Finally, we hope to provide a generic solver for any discrete choice model with T1EV shocks.
The scope of HARK is limited only by what users choose to put in it. We hope that
within a year of its debut, HARK will include a significant number of canonical models,
providing more building blocks for future researchers to create novel combinations and new
extensions.
                                                                                        
                                                                                        
<!--l. 665--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">6.3  </span> <a 
 id="x1-310006.3"></a>Bounty Hunting</h4>
<!--l. 665--><p class="noindent" >While HARK users are free to write and contribute any tools and models that they believe could
be helpful, building the toolKit in a &#8220;bottom up&#8221; style, the HARK team hopes to provide
mechanisms for targeted &#8220;top down&#8221; development. The team is working to secure grant funding for
HARK so as to offer &#8220;bounties&#8221; for particular models, tools, applications, or frameworks. Suppose
the team decides that the model in Important Paper X should be included as part of HARK; we
will issue a call for contributions to fill this hole, offering a modest prize of, say, $20,000 to the
programmer who submits the best implementation of the model, as judged by clearly stated
criteria.<span class="footnote-mark"><a 
href="HARKmanual38.html#fn38x0"><sup class="textsuperscript">38</sup></a></span><a 
 id="x1-31001f38"></a> 
The bounty would be announced as an Issue on HARK&#8217;s GitHub page, as well as in a potential
electronic digest of HARK news.
<!--l. 665--><p class="indent" >  Bounties might be placed on items as small as a single data analysis tool or as large as a
complex estimation of a large general equilibrium model, with prizes scaling accordingly. We
hasten to emphasize that we cannot guarantee funding for HARK, so the bounties (like
everything else in this section) are purely speculative. As economists, the HARK team
understands the incentive compatibility problems associated with asking researchers to
contribute significant amounts of their time, effort, and unique skills in service of a
tenuous concept like the Greater Good in exchange for even more tenuous Glory. We
acknowledge that economic researchers are also optimizing agents with their own preferences
over leisure and consumption, and agree that Greed is a valid mechanism to expand
HARK.
  <h4 class="subsectionHead"><span class="titlemark">6.4  </span> <a 
 id="x1-320006.4"></a>All Aboard the Ark</h4>
<!--l. 665--><p class="noindent" >As observant readers may have noticed, the HARK repository is hosted by a GitHub account
named Econ-Ark, with no explanation as to what this might mean. Looking a few years into the
future, the development team believes that HARK might be the first piece of a broader collection
of computational economics resources. HARK is open source but somewhat akin to an
exclusive club: contributions are required to adhere to standards and norms so as to foster
modularity and interoperability among models and tools. Consistent with its namesake ship,
the Econ-Ark has a significantly lower bar for admission, with a place on board for
everything.
<!--l. 665--><p class="indent" >  On one level, the Ark might serve as a warehouse for any and all quantitative models and
tools, for any economic purpose, in any subfield, and written in any language. Through
nearly unanimous feedback, the HARK team understands that many economists are
willing to share code that they have already written, but are reluctant to expend the
                                                                                        
                                                                                        
considerable effort to translate and format it for HARK. In the future, we will set up a
mechanism for code like this to be hosted on the Ark, with minimal requirements
imposed on its authors (and correspondingly minimal warranty for potential users).
Relevant projects on the Ark might become bounty targets for HARK, with users
incentivized to port the original code into Python and to meet HARK standards;
direct access to the original source code will significantly expedite the translation
process, and provide a suitable benchmark for testing and verifying the contribution to
HARK.
<!--l. 665--><p class="indent" >  On a different level, the Ark might also include cohesive toolkits like HARK, but geared
toward purposes other than heterogeneous agents macroeconomics models. For example, the
previously mentioned modules for networks among agents (and other agent-based modeling),
industrial organization and dynamic games, and traditional discrete choice models might become
their own toolkits, with some interoperability with HARK. In support of this, some of the tool
modules currently in HARK might be &#8220;promoted&#8221; and become universally shared across all
Econ-Ark toolkits.
<!--l. 665--><p class="indent" >  The dark secret of HARK is that it is named for heterogeneous agents macroeconomics, but
designed and written by structural microeconomists. The development team believes these
subfields to have considerable overlap in terms of methods and techniques, and that HARK
might not be noticed by half of its potential audience due to its name. In a general sense, the
Econ-Ark gives us cover to expand the scope of our efforts and/or rebrand the toolKit for an
alternative audience.   
</body></html> 

                                                                                        


