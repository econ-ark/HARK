<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>ConsMarkovModel &mdash; HARK 0.97 documentation</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.97',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="HARK 0.97 documentation" href="../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">HARK 0.97 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-ConsMarkovModel">
<span id="consmarkovmodel"></span><h1>ConsMarkovModel<a class="headerlink" href="#module-ConsMarkovModel" title="Permalink to this headline">¶</a></h1>
<p>Classes to solve and simulate consumption-savings model with a discrete, exogenous,
stochastic Markov state.  The only solver here extends ConsIndShockModel to
include a Markov state; the interest factor, permanent growth factor, and income
distribution can vary with the discrete state.</p>
<p class="rubric">Functions</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">CRRAutility</span></code>(c,&nbsp;gam)</td>
<td>Evaluates constant relative risk aversion (CRRA) utility of consumption c given risk aversion parameter gam.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">CRRAutilityP</span></code>(c,&nbsp;gam)</td>
<td>Evaluates constant relative risk aversion (CRRA) marginal utility of consumption c given risk aversion parameter gam.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">CRRAutilityPP</span></code>(c,&nbsp;gam)</td>
<td>Evaluates constant relative risk aversion (CRRA) marginal marginal utility of consumption c given risk aversion parameter gam.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">CRRAutilityP_inv</span></code>(uP,&nbsp;gam)</td>
<td>Evaluates the inverse of the CRRA marginal utility function (with risk aversion parameter gam) at a given marginal utility level uP.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">CRRAutilityP_invP</span></code>(u,&nbsp;gam)</td>
<td>Evaluates the derivative of the inverse of the CRRA marginal utility function (with risk aversion parameter gam) at a given marginal utility level uP.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">CRRAutility_inv</span></code>(u,&nbsp;gam)</td>
<td>Evaluates the inverse of the CRRA utility function (with risk aversion para- meter gam) at a given utility level u.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">CRRAutility_invP</span></code>(u,&nbsp;gam)</td>
<td>Evaluates the derivative of the inverse of the CRRA utility function (with risk aversion parameter gam) at a given utility level u.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">deepcopy</span></code>(x[,&nbsp;memo,&nbsp;_nil])</td>
<td>Deep copy operation on arbitrary Python objects.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">drawDiscrete</span></code>(N[,&nbsp;P,&nbsp;X,&nbsp;exact_match,&nbsp;seed])</td>
<td>Simulates N draws from a discrete distribution with probabilities P and outcomes X.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ConsMarkovModel.solveConsMarkov" title="ConsMarkovModel.solveConsMarkov"><code class="xref py py-obj docutils literal"><span class="pre">solveConsMarkov</span></code></a>(solution_next,&nbsp;IncomeDstn,&nbsp;...)</td>
<td>Solves a single period consumption-saving problem with risky income and stochastic transitions between discrete states, in a Markov fashion.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">utility</span></code>(c,&nbsp;gam)</td>
<td>Evaluates constant relative risk aversion (CRRA) utility of consumption c given risk aversion parameter gam.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">utilityP</span></code>(c,&nbsp;gam)</td>
<td>Evaluates constant relative risk aversion (CRRA) marginal utility of consumption c given risk aversion parameter gam.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">utilityPP</span></code>(c,&nbsp;gam)</td>
<td>Evaluates constant relative risk aversion (CRRA) marginal marginal utility of consumption c given risk aversion parameter gam.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">utilityP_inv</span></code>(uP,&nbsp;gam)</td>
<td>Evaluates the inverse of the CRRA marginal utility function (with risk aversion parameter gam) at a given marginal utility level uP.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">utilityP_invP</span></code>(u,&nbsp;gam)</td>
<td>Evaluates the derivative of the inverse of the CRRA marginal utility function (with risk aversion parameter gam) at a given marginal utility level uP.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">utility_inv</span></code>(u,&nbsp;gam)</td>
<td>Evaluates the inverse of the CRRA utility function (with risk aversion para- meter gam) at a given utility level u.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">utility_invP</span></code>(u,&nbsp;gam)</td>
<td>Evaluates the derivative of the inverse of the CRRA utility function (with risk aversion parameter gam) at a given utility level u.</td>
</tr>
</tbody>
</table>
<p class="rubric">Classes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">ConsIndShockSolver</span></code>(solution_next,&nbsp;...)</td>
<td>This class solves a single period of a standard consumption-saving problem.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ConsMarkovModel.ConsMarkovSolver" title="ConsMarkovModel.ConsMarkovSolver"><code class="xref py py-obj docutils literal"><span class="pre">ConsMarkovSolver</span></code></a>(solution_next,&nbsp;...)</td>
<td>A class to solve a single period consumption-saving problem with risky income and stochastic transitions between discrete states, in a Markov fashion.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">ConsumerSolution</span></code>([cFunc,&nbsp;vFunc,&nbsp;vPfunc,&nbsp;...])</td>
<td>A class representing the solution of a single period of a consumption-saving problem.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">CubicInterp</span></code>(x_list,&nbsp;y_list,&nbsp;dydx_list[,&nbsp;...])</td>
<td>An interpolating function using piecewise cubic splines.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">IndShockConsumerType</span></code>([cycles,&nbsp;time_flow])</td>
<td>A consumer type with idiosyncratic shocks to permanent and transitory income.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">LinearInterp</span></code>(x_list,&nbsp;y_list[,&nbsp;...])</td>
<td>A slight extension of scipy.interpolate&#8217;s UnivariateSpline for linear inter- polation.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">LowerEnvelope</span></code>(*functions)</td>
<td>The lower envelope of a finite set of 1D functions, each of which can be of any class that has the methods __call__, derivative, and eval_with_derivative.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">MargValueFunc</span></code>(cFunc,&nbsp;CRRA)</td>
<td>A class for representing a marginal value function in models where the standard envelope condition of v&#8217;(m) = u&#8217;(c(m)) holds (with CRRA utility).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ConsMarkovModel.MarkovConsumerType" title="ConsMarkovModel.MarkovConsumerType"><code class="xref py py-obj docutils literal"><span class="pre">MarkovConsumerType</span></code></a>([cycles,&nbsp;time_flow])</td>
<td>An agent in the Markov consumption-saving model.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">ValueFunc</span></code>(vFuncNvrs,&nbsp;CRRA)</td>
<td>A class for representing a value function.</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="ConsMarkovModel.ConsMarkovSolver">
<em class="property">class </em><code class="descclassname">ConsMarkovModel.</code><code class="descname">ConsMarkovSolver</code><span class="sig-paren">(</span><em>solution_next</em>, <em>IncomeDstn_list</em>, <em>LivPrb</em>, <em>DiscFac</em>, <em>CRRA</em>, <em>Rfree_list</em>, <em>PermGroFac_list</em>, <em>MrkvArray</em>, <em>BoroCnstArt</em>, <em>aXtraGrid</em>, <em>vFuncBool</em>, <em>CubicBool</em><span class="sig-paren">)</span><a class="headerlink" href="#ConsMarkovModel.ConsMarkovSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>A class to solve a single period consumption-saving problem with risky income
and stochastic transitions between discrete states, in a Markov fashion.
Extends ConsIndShockSolver, with identical inputs but for a discrete
Markov state, whose transition rule is summarized in MrkvArray.  Markov
states can differ in their interest factor, permanent growth factor, and
income distribution, so the inputs Rfree, PermGroFac, and IncomeDstn are
now arrays or lists specifying those values in each (succeeding) Markov state.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">addMPCandHumanWealth</span></code>(solution)</td>
<td>Take a solution and add human wealth and the bounding MPCs to it.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">addSSmNrm</span></code>(solution)</td>
<td>Finds steady state (normalized) market resources and adds it to the solution.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">addvFunc</span></code>(solution,&nbsp;EndOfPrdvP)</td>
<td>Creates the value function for this period and adds it to the solution.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">addvPPfunc</span></code>(solution)</td>
<td>Adds the marginal marginal value function to an existing solution, so that the next solver can evaluate vPP and thus use cubic interpolation.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">assignParameters</span></code>(solution_next,&nbsp;IncomeDstn,&nbsp;...)</td>
<td>Assigns period parameters as attributes of self for use by other methods</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ConsMarkovModel.ConsMarkovSolver.calcEndOfPrdvP" title="ConsMarkovModel.ConsMarkovSolver.calcEndOfPrdvP"><code class="xref py py-obj docutils literal"><span class="pre">calcEndOfPrdvP</span></code></a>()</td>
<td>Calculates end of period marginal value (and marginal marginal) value at each aXtra gridpoint for each current state, unconditional on the future Markov state (i.e.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ConsMarkovModel.ConsMarkovSolver.calcEndOfPrdvPP" title="ConsMarkovModel.ConsMarkovSolver.calcEndOfPrdvPP"><code class="xref py py-obj docutils literal"><span class="pre">calcEndOfPrdvPP</span></code></a>()</td>
<td>Calculates end-of-period marginal marginal value using a pre-defined array of next period market resources in self.mNrmNext.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ConsMarkovModel.ConsMarkovSolver.calcEndOfPrdvPcond" title="ConsMarkovModel.ConsMarkovSolver.calcEndOfPrdvPcond"><code class="xref py py-obj docutils literal"><span class="pre">calcEndOfPrdvPcond</span></code></a>()</td>
<td>Calculate end-of-period marginal value of assets at each point in aNrmNow conditional on a particular state occuring in the next period.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ConsMarkovModel.ConsMarkovSolver.calcHumWealthAndBoundingMPCs" title="ConsMarkovModel.ConsMarkovSolver.calcHumWealthAndBoundingMPCs"><code class="xref py py-obj docutils literal"><span class="pre">calcHumWealthAndBoundingMPCs</span></code></a>()</td>
<td>Calculates human wealth and the maximum and minimum MPC for each current period state, then stores them as attributes of self for use by other methods.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ConsMarkovModel.ConsMarkovSolver.conditionOnState" title="ConsMarkovModel.ConsMarkovSolver.conditionOnState"><code class="xref py py-obj docutils literal"><span class="pre">conditionOnState</span></code></a>(state_index)</td>
<td>Temporarily assume that a particular Markov state will occur in the succeeding period, and condition solver attributes on this assumption.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">defBoroCnst</span></code>(BoroCnstArt)</td>
<td>Defines the constrained portion of the consumption function as cFuncNowCnst, an attribute of self.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ConsMarkovModel.ConsMarkovSolver.defBoundary" title="ConsMarkovModel.ConsMarkovSolver.defBoundary"><code class="xref py py-obj docutils literal"><span class="pre">defBoundary</span></code></a>()</td>
<td>Find the borrowing constraint for each current state and save it as an attribute of self for use by other methods.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">defUtilityFuncs</span></code>()</td>
<td>Defines CRRA utility function for this period (and its derivatives, and their inverses), saving them as attributes of self for other methods to use.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">defValueFuncs</span></code>()</td>
<td>Defines the value and marginal value function for this period.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">getPointsForInterpolation</span></code>(EndOfPrdvP,&nbsp;aNrmNow)</td>
<td>Finds interpolation points (c,m) for the consumption function.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">makeBasicSolution</span></code>(EndOfPrdvP,&nbsp;aNrm,&nbsp;interpolator)</td>
<td>Given end of period assets and end of period marginal value, construct the basic solution for this period.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ConsMarkovModel.ConsMarkovSolver.makeCubiccFunc" title="ConsMarkovModel.ConsMarkovSolver.makeCubiccFunc"><code class="xref py py-obj docutils literal"><span class="pre">makeCubiccFunc</span></code></a>(mNrm,&nbsp;cNrm)</td>
<td>Make a cubic interpolation to represent the (unconstrained) consumption function conditional on the current period state.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">makeEndOfPrdvFunc</span></code>(EndOfPrdvP)</td>
<td>Construct the end-of-period value function for this period, storing it as an attribute of self for use by other methods.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ConsMarkovModel.ConsMarkovSolver.makeEndOfPrdvFuncCond" title="ConsMarkovModel.ConsMarkovSolver.makeEndOfPrdvFuncCond"><code class="xref py py-obj docutils literal"><span class="pre">makeEndOfPrdvFuncCond</span></code></a>()</td>
<td>Construct the end-of-period value function conditional on next period&#8217;s state.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ConsMarkovModel.ConsMarkovSolver.makeEndOfPrdvPfuncCond" title="ConsMarkovModel.ConsMarkovSolver.makeEndOfPrdvPfuncCond"><code class="xref py py-obj docutils literal"><span class="pre">makeEndOfPrdvPfuncCond</span></code></a>()</td>
<td>Construct the end-of-period marginal value function conditional on next period&#8217;s state.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ConsMarkovModel.ConsMarkovSolver.makeLinearcFunc" title="ConsMarkovModel.ConsMarkovSolver.makeLinearcFunc"><code class="xref py py-obj docutils literal"><span class="pre">makeLinearcFunc</span></code></a>(mNrm,&nbsp;cNrm)</td>
<td>Make a linear interpolation to represent the (unconstrained) consumption function conditional on the current period state.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">makePFcFunc</span></code>()</td>
<td>Makes the (linear) consumption function for this period.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ConsMarkovModel.ConsMarkovSolver.makeSolution" title="ConsMarkovModel.ConsMarkovSolver.makeSolution"><code class="xref py py-obj docutils literal"><span class="pre">makeSolution</span></code></a>(cNrm,&nbsp;mNrm)</td>
<td>Construct an object representing the solution to this period&#8217;s problem.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ConsMarkovModel.ConsMarkovSolver.makevFunc" title="ConsMarkovModel.ConsMarkovSolver.makevFunc"><code class="xref py py-obj docutils literal"><span class="pre">makevFunc</span></code></a>(solution)</td>
<td>Construct the value function for each current state.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">prepareToCalcEndOfPrdvP</span></code>()</td>
<td>Prepare to calculate end-of-period marginal value by creating an array of market resources that the agent could have next period, considering the grid of end-of-period assets and the distribution of shocks he might experience next period.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">prepareToSolve</span></code>()</td>
<td>Perform preparatory work before calculating the unconstrained consumption function.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">setAndUpdateValues</span></code>(solution_next,&nbsp;...)</td>
<td>Unpacks some of the inputs (and calculates simple objects based on them), storing the results in self for use by other methods.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ConsMarkovModel.ConsMarkovSolver.solve" title="ConsMarkovModel.ConsMarkovSolver.solve"><code class="xref py py-obj docutils literal"><span class="pre">solve</span></code></a>()</td>
<td>Solve the one period problem of the consumption-saving model with a Markov state.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">usePointsForInterpolation</span></code>(cNrm,&nbsp;mNrm,&nbsp;...)</td>
<td>Constructs a basic solution for this period, including the consumption function and marginal value function.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="ConsMarkovModel.ConsMarkovSolver.calcEndOfPrdvP">
<code class="descname">calcEndOfPrdvP</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ConsMarkovModel.ConsMarkovSolver.calcEndOfPrdvP" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates end of period marginal value (and marginal marginal) value
at each aXtra gridpoint for each current state, unconditional on the
future Markov state (i.e. weighting conditional end-of-period marginal
value by transition probabilities).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>none</strong></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">none</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ConsMarkovModel.ConsMarkovSolver.calcEndOfPrdvPP">
<code class="descname">calcEndOfPrdvPP</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ConsMarkovModel.ConsMarkovSolver.calcEndOfPrdvPP" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates end-of-period marginal marginal value using a pre-defined
array of next period market resources in self.mNrmNext.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>none</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>EndOfPrdvPP</strong> : np.array</p>
<blockquote class="last">
<div><p>End-of-period marginal marginal value of assets at each value in
the grid of assets.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ConsMarkovModel.ConsMarkovSolver.calcEndOfPrdvPcond">
<code class="descname">calcEndOfPrdvPcond</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ConsMarkovModel.ConsMarkovSolver.calcEndOfPrdvPcond" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate end-of-period marginal value of assets at each point in aNrmNow
conditional on a particular state occuring in the next period.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>None</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>EndOfPrdvP</strong> : np.array</p>
<blockquote class="last">
<div><p>A 1D array of end-of-period marginal value of assets.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ConsMarkovModel.ConsMarkovSolver.calcHumWealthAndBoundingMPCs">
<code class="descname">calcHumWealthAndBoundingMPCs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ConsMarkovModel.ConsMarkovSolver.calcHumWealthAndBoundingMPCs" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates human wealth and the maximum and minimum MPC for each current
period state, then stores them as attributes of self for use by other methods.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>none</strong></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">none</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ConsMarkovModel.ConsMarkovSolver.conditionOnState">
<code class="descname">conditionOnState</code><span class="sig-paren">(</span><em>state_index</em><span class="sig-paren">)</span><a class="headerlink" href="#ConsMarkovModel.ConsMarkovSolver.conditionOnState" title="Permalink to this definition">¶</a></dt>
<dd><p>Temporarily assume that a particular Markov state will occur in the
succeeding period, and condition solver attributes on this assumption.
Allows the solver to construct the future-state-conditional marginal
value function (etc) for that future state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>state_index</strong> : int</p>
<blockquote>
<div><p>Index of the future Markov state to condition on.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">none</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ConsMarkovModel.ConsMarkovSolver.defBoundary">
<code class="descname">defBoundary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ConsMarkovModel.ConsMarkovSolver.defBoundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the borrowing constraint for each current state and save it as an
attribute of self for use by other methods.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>none</strong></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">none</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ConsMarkovModel.ConsMarkovSolver.makeCubiccFunc">
<code class="descname">makeCubiccFunc</code><span class="sig-paren">(</span><em>mNrm</em>, <em>cNrm</em><span class="sig-paren">)</span><a class="headerlink" href="#ConsMarkovModel.ConsMarkovSolver.makeCubiccFunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a cubic interpolation to represent the (unconstrained) consumption
function conditional on the current period state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mNrm</strong> : np.array</p>
<blockquote>
<div><p>Array of normalized market resource values for interpolation.</p>
</div></blockquote>
<p><strong>cNrm</strong> : np.array</p>
<blockquote>
<div><p>Array of normalized consumption values for interpolation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">cFuncUnc: an instance of HARKinterpolation.CubicInterp</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ConsMarkovModel.ConsMarkovSolver.makeEndOfPrdvFuncCond">
<code class="descname">makeEndOfPrdvFuncCond</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ConsMarkovModel.ConsMarkovSolver.makeEndOfPrdvFuncCond" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the end-of-period value function conditional on next period&#8217;s
state.  NOTE: It might be possible to eliminate this method and replace
it with ConsIndShockSolver.makeEndOfPrdvFunc, but the self.X_cond
variables must be renamed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>none</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>EndofPrdvFunc_cond</strong> : ValueFunc</p>
<blockquote class="last">
<div><p>The end-of-period value function conditional on a particular state
occuring in the next period.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ConsMarkovModel.ConsMarkovSolver.makeEndOfPrdvPfuncCond">
<code class="descname">makeEndOfPrdvPfuncCond</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ConsMarkovModel.ConsMarkovSolver.makeEndOfPrdvPfuncCond" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the end-of-period marginal value function conditional on next
period&#8217;s state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>None</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>EndofPrdvPfunc_cond</strong> : MargValueFunc</p>
<blockquote class="last">
<div><p>The end-of-period marginal value function conditional on a particular
state occuring in the succeeding period.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ConsMarkovModel.ConsMarkovSolver.makeLinearcFunc">
<code class="descname">makeLinearcFunc</code><span class="sig-paren">(</span><em>mNrm</em>, <em>cNrm</em><span class="sig-paren">)</span><a class="headerlink" href="#ConsMarkovModel.ConsMarkovSolver.makeLinearcFunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a linear interpolation to represent the (unconstrained) consumption
function conditional on the current period state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mNrm</strong> : np.array</p>
<blockquote>
<div><p>Array of normalized market resource values for interpolation.</p>
</div></blockquote>
<p><strong>cNrm</strong> : np.array</p>
<blockquote>
<div><p>Array of normalized consumption values for interpolation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">cFuncUnc: an instance of HARKinterpolation.LinearInterp</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ConsMarkovModel.ConsMarkovSolver.makeSolution">
<code class="descname">makeSolution</code><span class="sig-paren">(</span><em>cNrm</em>, <em>mNrm</em><span class="sig-paren">)</span><a class="headerlink" href="#ConsMarkovModel.ConsMarkovSolver.makeSolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an object representing the solution to this period&#8217;s problem.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>cNrm</strong> : np.array</p>
<blockquote>
<div><p>Array of normalized consumption values for interpolation.  Each row
corresponds to a Markov state for this period.</p>
</div></blockquote>
<p><strong>mNrm</strong> : np.array</p>
<blockquote>
<div><p>Array of normalized market resource values for interpolation.  Each
row corresponds to a Markov state for this period.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>solution</strong> : ConsumerSolution</p>
<blockquote class="last">
<div><p>The solution to the single period consumption-saving problem. Includes
a consumption function cFunc (using cubic or linear splines), a marg-
inal value function vPfunc, a minimum acceptable level of normalized
market resources mNrmMin, normalized human wealth hNrm, and bounding
MPCs MPCmin and MPCmax.  It might also have a value function vFunc
and marginal marginal value function vPPfunc.  All of these attributes
are lists or arrays, with elements corresponding to the current
Markov state.  E.g. solution.cFunc[0] is the consumption function
when in the i=0 Markov state this period.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ConsMarkovModel.ConsMarkovSolver.makevFunc">
<code class="descname">makevFunc</code><span class="sig-paren">(</span><em>solution</em><span class="sig-paren">)</span><a class="headerlink" href="#ConsMarkovModel.ConsMarkovSolver.makevFunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the value function for each current state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>solution</strong> : ConsumerSolution</p>
<blockquote>
<div><p>The solution to the single period consumption-saving problem. Must
have a consumption function cFunc (using cubic or linear splines) as
a list with elements corresponding to the current Markov state.  E.g.
solution.cFunc[0] is the consumption function when in the i=0 Markov
state this period.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>vFuncNow</strong> : [ValueFunc]</p>
<blockquote class="last">
<div><p>A list of value functions (defined over normalized market resources
m) for each current period Markov state.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ConsMarkovModel.ConsMarkovSolver.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ConsMarkovModel.ConsMarkovSolver.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the one period problem of the consumption-saving model with a Markov state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>none</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>solution</strong> : ConsumerSolution</p>
<blockquote class="last">
<div><p>The solution to the single period consumption-saving problem. Includes
a consumption function cFunc (using cubic or linear splines), a marg-
inal value function vPfunc, a minimum acceptable level of normalized
market resources mNrmMin, normalized human wealth hNrm, and bounding
MPCs MPCmin and MPCmax.  It might also have a value function vFunc
and marginal marginal value function vPPfunc.  All of these attributes
are lists or arrays, with elements corresponding to the current
Markov state.  E.g. solution.cFunc[0] is the consumption function
when in the i=0 Markov state this period.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ConsMarkovModel.MarkovConsumerType">
<em class="property">class </em><code class="descclassname">ConsMarkovModel.</code><code class="descname">MarkovConsumerType</code><span class="sig-paren">(</span><em>cycles=1</em>, <em>time_flow=True</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#ConsMarkovModel.MarkovConsumerType" title="Permalink to this definition">¶</a></dt>
<dd><p>An agent in the Markov consumption-saving model.  His problem is defined by a sequence
of income distributions, survival probabilities, discount factors, and permanent
income growth rates, as well as time invariant values for risk aversion, the
interest rate, the grid of end-of-period assets, and how he is borrowing constrained.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">__call__</span></code>(**kwds)</td>
<td>Assign an arbitrary number of attributes to this agent, as a convenience.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ConsMarkovModel.MarkovConsumerType.advanceIncShks" title="ConsMarkovModel.MarkovConsumerType.advanceIncShks"><code class="xref py py-obj docutils literal"><span class="pre">advanceIncShks</span></code></a>()</td>
<td>Advance the permanent and transitory income shocks to the next period of the shock history objects.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">advancecFunc</span></code>()</td>
<td>Advance the consumption function to the next period in the solution.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">assignParameters</span></code>(**kwds)</td>
<td>Assign an arbitrary number of attributes to this agent.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">cFunc_terminal_</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ConsMarkovModel.MarkovConsumerType.calcBoundingValues" title="ConsMarkovModel.MarkovConsumerType.calcBoundingValues"><code class="xref py py-obj docutils literal"><span class="pre">calcBoundingValues</span></code></a>()</td>
<td>Calculate human wealth plus minimum and maximum MPC in an infinite horizon model with only one period repeated indefinitely.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">distance</span></code>(other)</td>
<td>A generic distance method, which requires the existence of an attribute called distance_criteria, giving a list of strings naming the attributes to be considered by the distance metric.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">initializeSim</span></code>([a_init,&nbsp;p_init,&nbsp;t_init,&nbsp;sim_prds])</td>
<td>Readies this type for simulation by clearing its history, initializing state variables, and setting time indices to their correct position.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">isSameThing</span></code>(solutionA,&nbsp;solutionB)</td>
<td>Compare two solutions to see if they are the &#8220;same.&#8221;  The model-specific solution class must have a method called distance, which takes another solution object as an input and returns the &#8220;distance&#8221; between the solutions.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ConsMarkovModel.MarkovConsumerType.makeEulerErrorFunc" title="ConsMarkovModel.MarkovConsumerType.makeEulerErrorFunc"><code class="xref py py-obj docutils literal"><span class="pre">makeEulerErrorFunc</span></code></a>([mMax,&nbsp;approx_inc_dstn])</td>
<td>Creates a &#8220;normalized Euler error&#8221; function for this instance, mapping from market resources to &#8220;consumption error per dollar of consumption.&#8221; Stores result in attribute eulerErrorFunc as an interpolated function.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ConsMarkovModel.MarkovConsumerType.makeIncShkHist" title="ConsMarkovModel.MarkovConsumerType.makeIncShkHist"><code class="xref py py-obj docutils literal"><span class="pre">makeIncShkHist</span></code></a>()</td>
<td>Makes histories of simulated income shocks for this consumer type by drawing from the discrete income distributions, respecting the Markov state for each agent in each period.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ConsMarkovModel.MarkovConsumerType.makeMrkvHist" title="ConsMarkovModel.MarkovConsumerType.makeMrkvHist"><code class="xref py py-obj docutils literal"><span class="pre">makeMrkvHist</span></code></a>()</td>
<td>Makes a history of simulated discrete Markov states, starting from the initial states in markov_init.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">postSolve</span></code>()</td>
<td>A method that is run immediately after the model is solved, to finalize the solution in some way.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">preSolve</span></code>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">resetRNG</span></code>()</td>
<td>Reset the random number generator for this type.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">simConsHistory</span></code>()</td>
<td>Simulates a history of bank balances, market resources, consumption, marginal propensity to consume, assets (after all actions), and permanent income given initial assets (normalized by permanent income).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#ConsMarkovModel.MarkovConsumerType.simOnePrd" title="ConsMarkovModel.MarkovConsumerType.simOnePrd"><code class="xref py py-obj docutils literal"><span class="pre">simOnePrd</span></code></a>()</td>
<td>Simulate a single period of a consumption-saving model with permanent and transitory income shocks.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">solution_terminal_</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">solve</span></code>()</td>
<td>Solve the model for this instance of an agent type by backward induction.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">timeFlip</span></code>()</td>
<td>Reverse the flow of time for this instance.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">timeFwd</span></code>()</td>
<td>Make time flow forward for this instance.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">timeReport</span></code>()</td>
<td>Report to the user the direction that time is currently &#8220;flowing&#8221; for this instance.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">timeRev</span></code>()</td>
<td>Make time flow backward for this instance.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">unpack_cFunc</span></code>()</td>
<td>&#8220;Unpacks&#8221; the consumption functions into their own field for easier access.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">update</span></code>()</td>
<td>Update the income process, the assets grid, and the terminal solution.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">updateAssetsGrid</span></code>()</td>
<td>Updates this agent&#8217;s end-of-period assets grid by constructing a multi- exponentially spaced grid of aXtra values.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">updateIncomeProcess</span></code>()</td>
<td>Updates this agent&#8217;s income process based on his own attributes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#ConsMarkovModel.MarkovConsumerType.updateSolutionTerminal" title="ConsMarkovModel.MarkovConsumerType.updateSolutionTerminal"><code class="xref py py-obj docutils literal"><span class="pre">updateSolutionTerminal</span></code></a>()</td>
<td>Update the terminal period solution.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">vFunc_terminal_</span></code></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="ConsMarkovModel.MarkovConsumerType.advanceIncShks">
<code class="descname">advanceIncShks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ConsMarkovModel.MarkovConsumerType.advanceIncShks" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance the permanent and transitory income shocks to the next period of
the shock history objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>none</strong></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">none</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ConsMarkovModel.MarkovConsumerType.calcBoundingValues">
<code class="descname">calcBoundingValues</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ConsMarkovModel.MarkovConsumerType.calcBoundingValues" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate human wealth plus minimum and maximum MPC in an infinite
horizon model with only one period repeated indefinitely.  Store results
as attributes of self.  Human wealth is the present discounted value of
expected future income after receiving income this period, ignoring mort-
ality.  The maximum MPC is the limit of the MPC as m &#8211;&gt; mNrmMin.  The
minimum MPC is the limit of the MPC as m &#8211;&gt; infty.  Results are all
np.array with elements corresponding to each Markov state.</p>
<p>NOT YET IMPLEMENTED FOR THIS CLASS</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>None</strong></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ConsMarkovModel.MarkovConsumerType.makeEulerErrorFunc">
<code class="descname">makeEulerErrorFunc</code><span class="sig-paren">(</span><em>mMax=100</em>, <em>approx_inc_dstn=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ConsMarkovModel.MarkovConsumerType.makeEulerErrorFunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a &#8220;normalized Euler error&#8221; function for this instance, mapping
from market resources to &#8220;consumption error per dollar of consumption.&#8221;
Stores result in attribute eulerErrorFunc as an interpolated function.
Has option to use approximate income distribution stored in self.IncomeDstn
or to use a (temporary) very dense approximation.</p>
<p>NOT YET IMPLEMENTED FOR THIS CLASS</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mMax</strong> : float</p>
<blockquote>
<div><p>Maximum normalized market resources for the Euler error function.</p>
</div></blockquote>
<p><strong>approx_inc_dstn</strong> : Boolean</p>
<blockquote>
<div><p>Indicator for whether to use the approximate discrete income distri-
bution stored in self.IncomeDstn[0], or to use a very accurate
discrete approximation instead.  When True, uses approximation in
IncomeDstn; when False, makes and uses a very dense approximation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ConsMarkovModel.MarkovConsumerType.makeIncShkHist">
<code class="descname">makeIncShkHist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ConsMarkovModel.MarkovConsumerType.makeIncShkHist" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes histories of simulated income shocks for this consumer type by
drawing from the discrete income distributions, respecting the Markov
state for each agent in each period.  Should be run after makeMrkvHist().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>none</strong></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">none</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ConsMarkovModel.MarkovConsumerType.makeMrkvHist">
<code class="descname">makeMrkvHist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ConsMarkovModel.MarkovConsumerType.makeMrkvHist" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a history of simulated discrete Markov states, starting from the
initial states in markov_init.  Assumes that MrkvArray is constant.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>none</strong></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">none</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ConsMarkovModel.MarkovConsumerType.simOnePrd">
<code class="descname">simOnePrd</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ConsMarkovModel.MarkovConsumerType.simOnePrd" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate a single period of a consumption-saving model with permanent
and transitory income shocks.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>none</strong></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">none</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ConsMarkovModel.MarkovConsumerType.updateSolutionTerminal">
<code class="descname">updateSolutionTerminal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ConsMarkovModel.MarkovConsumerType.updateSolutionTerminal" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the terminal period solution.  This method should be run when a
new AgentType is created or when CRRA changes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>none</strong></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">none</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="ConsMarkovModel.solveConsMarkov">
<code class="descclassname">ConsMarkovModel.</code><code class="descname">solveConsMarkov</code><span class="sig-paren">(</span><em>solution_next</em>, <em>IncomeDstn</em>, <em>LivPrb</em>, <em>DiscFac</em>, <em>CRRA</em>, <em>Rfree</em>, <em>PermGroFac</em>, <em>MrkvArray</em>, <em>BoroCnstArt</em>, <em>aXtraGrid</em>, <em>vFuncBool</em>, <em>CubicBool</em><span class="sig-paren">)</span><a class="headerlink" href="#ConsMarkovModel.solveConsMarkov" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a single period consumption-saving problem with risky income and
stochastic transitions between discrete states, in a Markov fashion.  Has
identical inputs as solveConsIndShock, except for a discrete 
Markov transitionrule MrkvArray.  Markov states can differ in their interest 
factor, permanent growth factor, and income distribution, so the inputs Rfree,
PermGroFac, and IncomeDstn are arrays or lists specifying those values in each
(succeeding) Markov state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>solution_next</strong> : ConsumerSolution</p>
<blockquote>
<div><p>The solution to next period&#8217;s one period problem.</p>
</div></blockquote>
<p><strong>IncomeDstn_list</strong> : [[np.array]]</p>
<blockquote>
<div><p>A length N list of income distributions in each succeeding Markov
state.  Each income distribution contains three arrays of floats,
representing a discrete approximation to the income process at the
beginning of the succeeding period. Order: event probabilities,
permanent shocks, transitory shocks.</p>
</div></blockquote>
<p><strong>LivPrb</strong> : float</p>
<blockquote>
<div><p>Survival probability; likelihood of being alive at the beginning of
the succeeding period.</p>
</div></blockquote>
<p><strong>DiscFac</strong> : float</p>
<blockquote>
<div><p>Intertemporal discount factor for future utility.</p>
</div></blockquote>
<p><strong>CRRA</strong> : float</p>
<blockquote>
<div><p>Coefficient of relative risk aversion.</p>
</div></blockquote>
<p><strong>Rfree_list</strong> : np.array</p>
<blockquote>
<div><p>Risk free interest factor on end-of-period assets for each Markov
state in the succeeding period.</p>
</div></blockquote>
<p><strong>PermGroGac_list</strong> : float</p>
<blockquote>
<div><p>Expected permanent income growth factor at the end of this period
for each Markov state in the succeeding period.</p>
</div></blockquote>
<p><strong>MrkvArray</strong> : numpy.array</p>
<blockquote>
<div><p>An NxN array representing a Markov transition matrix between discrete
states.  The i,j-th element of MrkvArray is the probability of
moving from state i in period t to state j in period t+1.</p>
</div></blockquote>
<p><strong>BoroCnstArt: float or None</strong></p>
<blockquote>
<div><p>Borrowing constraint for the minimum allowable assets to end the
period with.  If it is less than the natural borrowing constraint,
then it is irrelevant; BoroCnstArt=None indicates no artificial bor-
rowing constraint.</p>
</div></blockquote>
<p><strong>aXtraGrid: np.array</strong></p>
<blockquote>
<div><p>Array of &#8220;extra&#8221; end-of-period asset values&#8211; assets above the
absolute minimum acceptable level.</p>
</div></blockquote>
<p><strong>vFuncBool: boolean</strong></p>
<blockquote>
<div><p>An indicator for whether the value function should be computed and
included in the reported solution.</p>
</div></blockquote>
<p><strong>CubicBool: boolean</strong></p>
<blockquote>
<div><p>An indicator for whether the solver should use cubic or linear inter-
polation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>solution</strong> : ConsumerSolution</p>
<blockquote class="last">
<div><p>The solution to the single period consumption-saving problem. Includes
a consumption function cFunc (using cubic or linear splines), a marg-
inal value function vPfunc, a minimum acceptable level of normalized
market resources mNrmMin, normalized human wealth hNrm, and bounding
MPCs MPCmin and MPCmax.  It might also have a value function vFunc
and marginal marginal value function vPPfunc.  All of these attributes
are lists or arrays, with elements corresponding to the current
Markov state.  E.g. solution.cFunc[0] is the consumption function
when in the i=0 Markov state this period.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/generated/ConsMarkovModel.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">HARK 0.97 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, TEMP.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.1.
    </div>
  </body>
</html>